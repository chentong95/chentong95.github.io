<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Node.js 工具模块 | CT的博客乐园</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js 工具模块</h1><a id="logo" href="/.">CT的博客乐园</a><p class="description">愿你历尽千帆，归来仍是少年。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node.js 工具模块</h1><div class="post-meta"><a href="/2017/07/21/node15/#comments" class="comment-count"></a><p><span class="date">Jul 21, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>在 Node.js 模块库中有很多好用的模块。<a id="more"></a></p>
<h2 id="OS-模块"><a href="#OS-模块" class="headerlink" title="OS 模块"></a>OS 模块</h2><p>提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var os = require(<span class="string">"os"</span>)</div></pre></td></tr></table></figure></p>
<p><strong>方法</strong></p>
<ul>
<li>os.tmpdir()<br>返回操作系统的默认临时文件夹。</li>
<li>os.endianness()<br>返回 CPU 的字节序，可能的是 “BE” 或 “LE”。</li>
<li>os.hostname()<br>返回操作系统的主机名。</li>
<li>os.type()<br>返回操作系统名</li>
<li>os.platform()<br>返回操作系统名</li>
<li>os.arch()<br>返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。</li>
<li>os.release()<br>返回操作系统的发行版本。</li>
<li>os.uptime()<br>返回操作系统运行的时间，以秒为单位。</li>
<li>os.loadavg()<br>返回一个包含 1、5、15 分钟平均负载的数组。</li>
<li>os.totalmem()<br>返回系统内存总量，单位为字节。</li>
<li>os.freemem()<br>返回操作系统空闲内存量，单位是字节。</li>
<li>os.cpus()<br>返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。</li>
<li>os.networkInterfaces()<br>获得网络接口列表。</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>os.EOL<br>定义了操作系统的行尾符的常量。</li>
</ul>
<p><strong>实例</strong><br>创建 main.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var os = require(<span class="string">"os"</span>);</div><div class="line">// CPU 的字节序</div><div class="line">console.log(<span class="string">'endianness : '</span> + os.endianness());</div><div class="line">// 操作系统名</div><div class="line">console.log(<span class="string">'type : '</span> + os.type());</div><div class="line">// 操作系统名</div><div class="line">console.log(<span class="string">'platform : '</span> + os.platform());</div><div class="line">// 系统内存总量</div><div class="line">console.log(<span class="string">'total memory : '</span> + os.totalmem() + <span class="string">" bytes."</span>);</div><div class="line">// 操作系统空闲内存量</div><div class="line">console.log(<span class="string">'free memory : '</span> + os.freemem() + <span class="string">" bytes."</span>);</div></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line">endianness : LE</div><div class="line">type : Windows_NT</div><div class="line">platform : win32</div><div class="line">total memory : <span class="number">4221722624</span> bytes.</div><div class="line">free memory : <span class="number">1954045952</span> bytes.</div></pre></td></tr></table></figure></p>
<h2 id="Path-模块"><a href="#Path-模块" class="headerlink" title="Path 模块"></a>Path 模块</h2><p>提供了处理和转换文件路径的工具,我们可以通过以下方式引入该模块：</p>
<p><strong>方法</strong></p>
<ul>
<li>path.normalize(p)<br>规范化路径，注意’..’ 和 ‘.’。</li>
<li>path.join([path1][, path2][, …])<br>用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\”。</li>
<li>path.resolve([from …], to)<br>将 to 参数解析为绝对路径。</li>
<li>path.isAbsolute(path)<br>判断参数 path 是否是绝对路径。</li>
<li>path.relative(from, to)<br>用于将相对路径转为绝对路径。</li>
<li>path.dirname(p)<br>返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。</li>
<li>path.basename(p[, ext])<br>返回路径中的最后一部分。同 Unix 命令 bashname 类似。</li>
<li>path.extname(p)<br>返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。</li>
<li>path.parse(pathString)<br>返回路径字符串的对象。</li>
<li>path.format(pathObject)<br>从对象中返回路径字符串，和 path.parse 相反。</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>path.sep<br>平台的文件路径分隔符，’\‘ 或 ‘/‘。</li>
<li>path.delimiter<br>平台的分隔符, ; or ‘:’.</li>
<li>path.posix<br>提供上述 path 的方法，不过总是以 posix 兼容的方式交互。</li>
<li>path.win32<br>提供上述 path 的方法，不过总是以 win32 兼容的方式交互。</li>
</ul>
<p><strong>实例</strong><br>创建 main.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var path = require(<span class="string">"path"</span>);</div><div class="line">// 格式化路径</div><div class="line">console.log(<span class="string">'normalization : '</span> + path.normalize(<span class="string">'/test/test1//2slashes/1slash/tab/..'</span>));</div><div class="line">// 连接路径</div><div class="line">console.log(<span class="string">'joint path : '</span> + path.join(<span class="string">'/test'</span>, <span class="string">'test1'</span>, <span class="string">'2slashes/1slash'</span>, <span class="string">'tab'</span>, <span class="string">'..'</span>));</div><div class="line">// 转换为绝对路径</div><div class="line">console.log(<span class="string">'resolve : '</span> + path.resolve(<span class="string">'main.js'</span>));</div><div class="line">// 路径中文件的后缀名</div><div class="line">console.log(<span class="string">'ext name : '</span> + path.extname(<span class="string">'main.js'</span>));</div></pre></td></tr></table></figure></p>
<p>代码执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line">normalization : \test\test1\<span class="number">2</span>slashes\<span class="number">1</span>slash</div><div class="line">joint path : \test\test1\<span class="number">2</span>slashes\<span class="number">1</span>slash</div><div class="line">resolve : F:\Node\<span class="number">13</span> 工具模块\path\main.js</div><div class="line">ext name : .js</div></pre></td></tr></table></figure></p>
<h2 id="Net-模块"><a href="#Net-模块" class="headerlink" title="Net 模块"></a>Net 模块</h2><p>用于底层的网络通信。提供了服务端和客户端的的操作。我们可以通过以下方式引入该模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var net = require(<span class="string">"net"</span>)</div></pre></td></tr></table></figure></p>
<p><strong>方法</strong></p>
<ul>
<li>net.createServer([options][, connectionListener])<br>创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。</li>
<li>net.connect(options[, connectionListener])<br>返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。<br>当 socket 建立的时候，将会触发 ‘connect’ 事件。</li>
<li>net.createConnection(options[, connectionListener])<br>创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。</li>
<li>net.connect(port[, host][, connectListener])<br>创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。</li>
<li>net.createConnection(port[, host][, connectListener])<br>创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。</li>
<li>net.connect(path[, connectListener])<br>创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。</li>
<li>net.createConnection(path[, connectListener])<br>创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。</li>
<li>net.isIP(input)<br>检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。</li>
<li>net.isIPv4(input)<br>如果输入的地址为 IPV4， 返回 true，否则返回 false。</li>
<li>net.isIPv6(input)<br>如果输入的地址为 IPV6， 返回 true，否则返回 false。</li>
</ul>
<h3 id="net-Server"><a href="#net-Server" class="headerlink" title="net.Server"></a>net.Server</h3><p>net.Server通常用于创建一个 TCP 或本地服务器。</p>
<ul>
<li>server.listen(port[, host][, backlog][, callback])<br>监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。</li>
<li>server.listen(path[, callback])<br>通过指定 path 的连接，启动一个本地 socket 服务器。</li>
<li>server.listen(handle[, callback])<br>通过指定句柄连接。</li>
<li>server.listen(options[, callback])<br>options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。</li>
<li>server.close([callback])<br>服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。</li>
<li>server.address()<br>操作系统返回绑定的地址，协议族名和服务器端口。</li>
<li>server.unref()<br>如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。</li>
<li>server.ref()<br>与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</li>
<li>server.getConnections(callback)<br>异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。</li>
</ul>
<p><strong>事件</strong></p>
<ul>
<li>listening<br>当服务器调用 server.listen 绑定后会触发。</li>
<li>connection<br>当新连接创建后会被触发。socket 是 net.Socket实例。</li>
<li>close<br>服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。</li>
<li>error<br>发生错误时触发。’close’ 事件将被下列事件直接调用。</li>
</ul>
<h3 id="net-Socket"><a href="#net-Socket" class="headerlink" title="net.Socket"></a>net.Socket</h3><p>net.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。<br><strong>事件</strong><br>net.Socket 事件有：</p>
<ul>
<li>lookup<br>在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。</li>
<li>connect<br>成功建立 socket 连接时触发。</li>
<li>data<br>当接收到数据时触发。</li>
<li>end<br>当 socket 另一端发送 FIN 包时，触发该事件。</li>
<li>timeout<br>当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。</li>
<li>drain<br>当写缓存为空得时候触发。可用来控制上传。</li>
<li>error<br>错误发生时触发。</li>
<li>close<br>当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。</li>
</ul>
<p><strong>属性</strong><br>net.Socket 提供了很多有用的属性，便于控制 socket 交互：</p>
<ul>
<li>socket.bufferSize<br>该属性显示了要写入缓冲区的字节数。</li>
<li>socket.remoteAddress<br>远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。</li>
<li>socket.remoteFamily<br>远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。</li>
<li>socket.remotePort<br>远程端口，数字表示，例如：80 or 21。</li>
<li>socket.localAddress<br>网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。</li>
<li>socket.localPort<br>本地端口地址，数字表示。例如：80 or 21。</li>
<li>socket.bytesRead<br>接收到得字节数。</li>
<li>socket.bytesWritten<br>发送的字节数。<br><strong>方法</strong></li>
<li>new net.Socket([options])<br>构造一个新的 socket 对象。</li>
<li>socket.connect(port[, host][, connectListener])<br>指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</li>
<li>socket.connect(path[, connectListener])<br>打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。</li>
<li>socket.setEncoding([encoding])<br>设置编码</li>
<li>socket.write(data[, encoding][, callback])<br>在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。</li>
<li>socket.end([data][, encoding])<br>半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。</li>
<li>socket.destroy()<br>确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。</li>
<li>socket.pause()<br>暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。</li>
<li>socket.resume()<br>调用 pause() 后想恢复读取数据。</li>
<li>socket.setTimeout(timeout[, callback])<br>socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。</li>
<li>socket.setNoDelay([noDelay])<br>禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。</li>
<li>socket.setKeepAlive([enable][, initialDelay])<br>禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.</li>
<li>socket.address()<br>操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。</li>
<li>socket.unref()<br>如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。</li>
<li>socket.ref()<br>与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。</li>
</ul>
<p><strong>实例</strong><br>创建 server.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var net = require(<span class="string">'net'</span>);</div><div class="line">var server = net.createServer(function(connection) &#123;</div><div class="line">   console.log(<span class="string">'client connected'</span>);</div><div class="line">   connection.on(<span class="string">'end'</span>, function() &#123;</div><div class="line">      console.log(<span class="string">'客户端关闭连接'</span>);</div><div class="line">   &#125;);</div><div class="line">   connection.write(<span class="string">'Hello World!\r\n'</span>);</div><div class="line">   connection.pipe(connection);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8080</span>, function() &#123;</div><div class="line">  console.log(<span class="string">'server is listening'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上服务端代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node server.js</div><div class="line">server <span class="keyword">is</span> listening   <span class="comment"># 服务已创建并监听 8080 端口</span></div></pre></td></tr></table></figure></p>
<p>新开一个窗口，创建 client.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var net = require(<span class="string">'net'</span>);</div><div class="line">var client = net.connect(&#123;port: <span class="number">8080</span>&#125;, function() &#123;</div><div class="line">   console.log(<span class="string">'连接到服务器！'</span>);  </div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'data'</span>, function(data) &#123;</div><div class="line">   console.log(data.toString());</div><div class="line">   client.end();</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'end'</span>, function() &#123;</div><div class="line">   console.log(<span class="string">'断开与服务器的连接'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上客户端的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">连接到服务器！</div><div class="line">Hello World!</div><div class="line">断开与服务器的连接</div></pre></td></tr></table></figure></p>
<h2 id="DNS-模块"><a href="#DNS-模块" class="headerlink" title="DNS 模块"></a>DNS 模块</h2><p>用于解析域名。引入 DNS 模块语法格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var dns = require(<span class="string">"dns"</span>)</div></pre></td></tr></table></figure></p>
<p><strong>方法</strong></p>
<ul>
<li>dns.lookup(hostname[, options], callback)<br>将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。</li>
<li>dns.lookupService(address, port, callback)<br>使用 getnameinfo 解析传入的地址和端口为域名和服务。</li>
<li>dns.resolve(hostname[, rrtype], callback)<br>将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。</li>
<li>dns.resolve4(hostname, callback)<br>和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。</li>
<li>dns.resolve6(hostname, callback)<br>和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）</li>
<li>dns.resolveMx(hostname, callback)<br>和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。</li>
<li>dns.resolveTxt(hostname, callback)<br>和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。</li>
<li>dns.resolveSrv(hostname, callback)<br>和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。</li>
<li>dns.resolveSoa(hostname, callback)<br>和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。</li>
<li>dns.resolveNs(hostname, callback)<br>和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。</li>
<li>dns.resolveCname(hostname, callback)<br>和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。</li>
<li>dns.reverse(ip, callback)<br>反向解析 IP 地址，指向该 IP 地址的域名数组。</li>
<li>dns.getServers()<br>返回一个用于当前解析的 IP 地址数组的字符串。</li>
<li>dns.setServers(servers)<br>指定一组 IP 地址作为解析服务器。</li>
</ul>
<p><strong>rrtypes</strong><br>以下列出了 dns.resolve() 方法中有效的 rrtypes值:<br>‘A’ IPV4 地址, 默认<br>‘AAAA’ IPV6 地址<br>‘MX’ 邮件交换记录<br>‘TXT’ text 记录<br>‘SRV’ SRV 记录<br>‘PTR’ 用来反向 IP 查找<br>‘NS’ 域名服务器记录<br>‘CNAME’ 别名记录<br>‘SOA’ 授权记录的初始值</p>
<p><strong>错误码</strong><br>每次 DNS 查询都可能返回以下错误码：<br>dns.NODATA: 无数据响应。<br>dns.FORMERR: 查询格式错误。<br>dns.SERVFAIL: 常规失败。<br>dns.NOTFOUND: 没有找到域名。<br>dns.NOTIMP: 未实现请求的操作。<br>dns.REFUSED: 拒绝查询。<br>dns.BADQUERY: 查询格式错误。<br>dns.BADNAME: 域名格式错误。<br>dns.BADFAMILY: 地址协议不支持。<br>dns.BADRESP: 回复格式错误。<br>dns.CONNREFUSED: 无法连接到 DNS 服务器。<br>dns.TIMEOUT: 连接 DNS 服务器超时。<br>dns.EOF: 文件末端。<br>dns.FILE: 读文件错误。<br>dns.NOMEM: 内存溢出。<br>dns.DESTRUCTION: 通道被摧毁。<br>dns.BADSTR: 字符串格式错误。<br>dns.BADFLAGS: 非法标识符。<br>dns.NONAME: 所给主机不是数字。<br>dns.BADHINTS: 非法HINTS标识符。<br>dns.NOTINITIALIZED: c c-ares 库尚未初始化。<br>dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。<br>dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。<br>dns.CANCELLED: 取消 DNS 查询。</p>
<p><strong>实例</strong><br>创建 main.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var dns = require(<span class="string">'dns'</span>);</div><div class="line">dns.lookup(<span class="string">'www.github.com'</span>, function onLookup(err, address, family) &#123;</div><div class="line">   console.log(<span class="string">'ip 地址:'</span>, address);</div><div class="line">   dns.reverse(address, function (err, hostnames) &#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">      console.log(err.stack);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   console.log(<span class="string">'反向解析 '</span> + address + <span class="string">': '</span> + JSON.stringify(hostnames));</div><div class="line">&#125;);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>执行以上代码，结果如下所示:<br>address: 192.30.252.130<br>reverse for 192.30.252.130: [“github.com”]</p>
<h2 id="Domain-模块"><a href="#Domain-模块" class="headerlink" title="Domain 模块"></a>Domain 模块</h2><p>简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。引入 Domain 模块语法格式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var domain = require(<span class="string">"domain"</span>)</div></pre></td></tr></table></figure></p>
<p>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(‘uncaughtException’)不同。<br>Domain 模块可分为隐式绑定和显式绑定：</p>
<ul>
<li>隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象</li>
<li>显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>domain.run(function)<br>在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</li>
<li>domain.add(emitter)<br>显式的增加事件</li>
<li>domain.remove(emitter)<br>删除事件。</li>
<li>domain.bind(callback)<br>返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。</li>
<li>domain.intercept(callback)<br>和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。</li>
<li>domain.enter()<br>进入一个异步调用的上下文，绑定到domain。</li>
<li>domain.exit()<br>退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。</li>
<li>domain.dispose()<br>释放一个domain对象，让node进程回收这部分资源。</li>
<li>domain.create()<br>返回一个domain对象。</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>domain.members<br>已加入domain对象的域定时器和事件发射器的数组。</li>
</ul>
<p><strong>实例</strong><br>创建 main.js 文件，代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var EventEmitter = require(<span class="string">"events"</span>).EventEmitter;</div><div class="line">var domain = require(<span class="string">"domain"</span>);</div><div class="line">var emitter1 = new EventEmitter();</div><div class="line">// 创建域</div><div class="line">var domain1 = domain.create();</div><div class="line">domain1.on(<span class="string">'error'</span>, function(err)&#123;</div><div class="line">   console.log(<span class="string">"domain1 处理这个错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line">// 显式绑定</div><div class="line">domain1.add(emitter1);</div><div class="line">emitter1.on(<span class="string">'error'</span>,function(err)&#123;</div><div class="line">   console.log(<span class="string">"监听器处理此错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line">emitter1.emit(<span class="string">'error'</span>,new Error(<span class="string">'通过监听器来处理'</span>));</div><div class="line">emitter1.removeAllListeners(<span class="string">'error'</span>);</div><div class="line">emitter1.emit(<span class="string">'error'</span>,new Error(<span class="string">'通过 domain1 处理'</span>));</div><div class="line">var domain2 = domain.create();</div><div class="line">domain2.on(<span class="string">'error'</span>, function(err)&#123;</div><div class="line">   console.log(<span class="string">"domain2 处理这个错误 ("</span>+err.message+<span class="string">")"</span>);</div><div class="line">&#125;);</div><div class="line">// 隐式绑定</div><div class="line">domain2.run(function()&#123;</div><div class="line">   var emitter2 = new EventEmitter();</div><div class="line">   emitter2.emit(<span class="string">'error'</span>,new Error(<span class="string">'通过 domain2 处理'</span>));</div><div class="line">&#125;);</div><div class="line">domain1.remove(emitter1);</div><div class="line">emitter1.emit(<span class="string">'error'</span>, new Error(<span class="string">'转换为异常，系统将崩溃!'</span>));</div></pre></td></tr></table></figure></p>
<p>执行以上代码，结果如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">监听器处理此错误 (通过监听器来处理)</div><div class="line">domain1 处理这个错误 (通过 domain1 处理)</div><div class="line">domain2 处理这个错误 (通过 domain2 处理)</div><div class="line">events.js:<span class="number">72</span></div><div class="line">        throw er; // Unhandled <span class="string">'error'</span> event</div><div class="line">              ^</div><div class="line">Error: 转换为异常，系统将崩溃!</div><div class="line">    at Object.&lt;anonymous&gt; (/www/node/main.js:<span class="number">40</span>:<span class="number">24</span>)</div><div class="line">    at Module._compile (module.js:<span class="number">456</span>:<span class="number">26</span>)</div><div class="line">    at Object.Module._extensions..js (module.js:<span class="number">474</span>:<span class="number">10</span>)</div><div class="line">    at Module.load (module.js:<span class="number">356</span>:<span class="number">32</span>)</div><div class="line">    at Function.Module._load (module.js:<span class="number">312</span>:<span class="number">12</span>)</div><div class="line">    at Function.Module.runMain (module.js:<span class="number">497</span>:<span class="number">10</span>)</div><div class="line">    at startup (node.js:<span class="number">119</span>:<span class="number">16</span>)</div><div class="line">    at node.js:<span class="number">929</span>:<span class="number">3</span></div></pre></td></tr></table></figure></p>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/07/27/node16/" class="pre">Node.js Web 模块</a><a href="/2017/07/20/node14/" class="next">Node.js GET/POST请求</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#OS-模块"><span class="toc-text">OS 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path-模块"><span class="toc-text">Path 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Net-模块"><span class="toc-text">Net 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net-Server"><span class="toc-text">net.Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-Socket"><span class="toc-text">net.Socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-模块"><span class="toc-text">DNS 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Domain-模块"><span class="toc-text">Domain 模块</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node22/">Node.js 连接 MongoDB</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node21/">Node.js 连接 MySQL</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node20/">Node.js JXcore 打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node19/">Node.js 多进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node18/">Node.js RESTful API</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node17/">Node.js Express 框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/node16/">Node.js Web 模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/21/node15/">Node.js 工具模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node14/">Node.js GET/POST请求</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node13/">Node.js 文件系统</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/node/" style="font-size: 15px;">node</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.runoob.com/" title="菜鸟教程" target="_blank">菜鸟教程</a><ul></ul><a href="http://www.imooc.com/" title="慕课网" target="_blank">慕课网</a><ul></ul><a href="http://www.ui.cn/" title="UI中国" target="_blank">UI中国</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p> <span> Copyright &copy;<a href="/." rel="nofollow">又见花田半亩.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>