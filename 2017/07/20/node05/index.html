<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Node.js EventEmitter | CT的博客乐园</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js EventEmitter</h1><a id="logo" href="/.">CT的博客乐园</a><p class="description">愿你走出半生，归来仍是少年。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node.js EventEmitter</h1><div class="post-meta"><a href="/2017/07/20/node05/#comments" class="comment-count"></a><p><span class="date">Jul 20, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。<a id="more"></a><br>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。<br>你可以通过require(“events”);来访问该模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 引入 events 模块</div><div class="line">var events = require(<span class="string">'events'</span>);</div><div class="line">// 创建 eventEmitter 对象</div><div class="line">var eventEmitter = new events.EventEmitter();</div></pre></td></tr></table></figure></p>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。<br>下面我们用一个简单的例子说明 EventEmitter 的用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//event.js 文件</div><div class="line">var EventEmitter = require(<span class="string">'events'</span>).EventEmitter;</div><div class="line">var event = new EventEmitter();</div><div class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	console.log(<span class="string">'some_event 事件触发'</span>);</div><div class="line">&#125;);</div><div class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">	event.emit(<span class="string">'some_event'</span>);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure></p>
<p>执行结果如下：<br>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node event.js</div><div class="line">some_event 事件触发</div></pre></td></tr></table></figure></p>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。<br>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//event.js 文件</div><div class="line">var events = require(<span class="string">'events'</span>);</div><div class="line">var emitter = new events.EventEmitter();</div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="keyword">function</span>(arg1, arg2) &#123;</div><div class="line">	console.log(<span class="string">'listener1'</span>, arg1, arg2);</div><div class="line">&#125;);</div><div class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="keyword">function</span>(arg1, arg2) &#123;</div><div class="line">	console.log(<span class="string">'listener2'</span>, arg1, arg2);</div><div class="line">&#125;);</div><div class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>);</div></pre></td></tr></table></figure></p>
<p>执行以上代码，运行的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node event.js</div><div class="line">listener1 arg1 参数 arg2 参数</div><div class="line">listener2 arg1 参数 arg2 参数</div></pre></td></tr></table></figure>
<p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。<br>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>addListener(event, listener)<br>为指定事件添加一个监听器到监听器数组的尾部。<br>on(event, listener)<br>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.on(<span class="string">'connection'</span>, <span class="keyword">function</span> (stream) &#123;</div><div class="line">  console.log(<span class="string">'someone connected!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>once(event, listener)<br>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.once(<span class="string">'connection'</span>, <span class="keyword">function</span> (stream) &#123;</div><div class="line">  console.log(<span class="string">'Ah, we have our first user!'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>removeListener(event, listener)<br>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br>它接受两个参数，第一个是事件名称，第二个是回调函数名称。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var callback = <span class="keyword">function</span>(stream) &#123;</div><div class="line">  console.log(<span class="string">'someone connected!'</span>);</div><div class="line">&#125;;</div><div class="line">server.on(<span class="string">'connection'</span>, callback);</div><div class="line">// ...</div><div class="line">server.removeListener(<span class="string">'connection'</span>, callback);</div></pre></td></tr></table></figure></p>
<p>removeAllListeners([event])<br>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>
<p>setMaxListeners(n)<br>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>
<p>listeners(event)<br>返回指定事件的监听器数组。</p>
<p>emit(event, [arg1], [arg2], […])<br>按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>listenerCount(emitter, event)<br>返回指定事件的监听器数量。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>newListener(event, listener)<br>event - 字符串，事件名称<br>listener - 处理事件函数<br>该事件在添加新监听器时被触发。</p>
<p>removeListener(event, listener)<br>event - 字符串，事件名称<br>listener - 处理事件函数<br>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。<br>创建 main.js 文件，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var events = require(<span class="string">'events'</span>);</div><div class="line">var eventEmitter = new events.EventEmitter();</div><div class="line">// 监听器 <span class="comment">#1</span></div><div class="line">var listener1 = <span class="keyword">function</span> <span class="function"><span class="title">listener1</span></span>() &#123;</div><div class="line">   console.log(<span class="string">'监听器 listener1 执行。'</span>);</div><div class="line">&#125;</div><div class="line">// 监听器 <span class="comment">#2</span></div><div class="line">var listener2 = <span class="keyword">function</span> <span class="function"><span class="title">listener2</span></span>() &#123;</div><div class="line">  console.log(<span class="string">'监听器 listener2 执行。'</span>);</div><div class="line">&#125;</div><div class="line">// 绑定 connection 事件，处理函数为 listener1</div><div class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</div><div class="line">// 绑定 connection 事件，处理函数为 listener2</div><div class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</div><div class="line">var eventListeners = require(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</div><div class="line">console.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</div><div class="line">// 处理 connection 事件</div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div><div class="line">// 移除监绑定的 listener1 函数</div><div class="line">eventEmitter.removeListener(<span class="string">'connection'</span>, listener1);</div><div class="line">console.log(<span class="string">"listener1 不再受监听。"</span>);</div><div class="line">// 触发连接事件</div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div><div class="line">eventListeners = require(<span class="string">'events'</span>).EventEmitter.listenerCount(eventEmitter,<span class="string">'connection'</span>);</div><div class="line">console.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</div><div class="line">console.log(<span class="string">"程序执行完毕。"</span>);</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line">2 个监听器监听连接事件。</div><div class="line">监听器 listener1 执行。</div><div class="line">监听器 listener2 执行。</div><div class="line">listener1 不再受监听。</div><div class="line">监听器 listener2 执行。</div><div class="line">1 个监听器监听连接事件。</div><div class="line">程序执行完毕。</div></pre></td></tr></table></figure></p>
<h2 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h2><p>error 事件<br>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。<br>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。<br>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var events = require(<span class="string">'events'</span>);</div><div class="line">var emitter = new events.EventEmitter();</div><div class="line">emitter.emit(<span class="string">'error'</span>);</div></pre></td></tr></table></figure></p>
<p>运行时会显示以下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">node.js:201</div><div class="line">throw e; // process.nextTick error, or <span class="string">'error'</span> event on first tick</div><div class="line">^</div><div class="line">Error: Uncaught, unspecified <span class="string">'error'</span> event.</div><div class="line">at EventEmitter.emit (events.js:50:15)</div><div class="line">at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9)</div><div class="line">at Module._compile (module.js:441:26)</div><div class="line">at Object..js (module.js:459:10)</div><div class="line">at Module.load (module.js:348:31)</div><div class="line">at Function._load (module.js:308:12)</div><div class="line">at Array.0 (module.js:479:10)</div><div class="line">at EventEmitter._tickCallback (node.js:192:40)</div></pre></td></tr></table></figure></p>
<h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。<br>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
</div><div class="tags"><a href="/tags/node/">node</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/07/20/node06/" class="pre">Node.js Buffer(缓冲区)</a><a href="/2017/07/20/node04/" class="next">Node.js 事件循环</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventEmitter-类"><span class="toc-text">EventEmitter 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例"><span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error事件"><span class="toc-text">error事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承-EventEmitter"><span class="toc-text">继承 EventEmitter</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node10/">Node.js 路由</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node09/">Node.js 函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node08/">Node.js模块系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node07/">Node.js Stream(流)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node06/">Node.js Buffer(缓冲区)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node05/">Node.js EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node04/">Node.js 事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node03/">Node.js 回调函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node02/">Node.js REPL(交互式解释器)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/node01/">Node.js 创建第一个应用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/node/" style="font-size: 15px;">node</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.runoob.com/" title="菜鸟教程" target="_blank">菜鸟教程</a><ul></ul><a href="http://www.imooc.com/" title="慕课网" target="_blank">慕课网</a><ul></ul><a href="http://www.ui.cn/" title="UI中国" target="_blank">UI中国</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p> <span> Copyright &copy;<a href="/." rel="nofollow">又见花田半亩.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>