[{"title":"Node.js RESTful API","date":"2017-07-27T01:42:24.000Z","path":"2017/07/27/node18/","text":"REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 HTTP 方法以下为 REST 基本架构的四个方法： GET - 用于获取数据。 PUT - 用于更新或添加数据。 DELETE - 用于删除数据。 POST - 用于添加数据。 RESTful Web ServicesWeb service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。基于 REST 架构的 Web Services 即是 RESTful。由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。更多介绍，可以查看：http://www.runoob.com/w3cnote/restful-architecture.html 创建 RESTful首先，创建一个 json 数据资源文件 users.json，内容如下：1234567891011121314151617181920&#123; \"user1\" : &#123; \"name\" : \"mahesh\", \"password\" : \"password1\", \"profession\" : \"teacher\", \"id\": 1 &#125;, \"user2\" : &#123; \"name\" : \"suresh\", \"password\" : \"password2\", \"profession\" : \"librarian\", \"id\": 2 &#125;, \"user3\" : &#123; \"name\" : \"ramesh\", \"password\" : \"password3\", \"profession\" : \"clerk\", \"id\": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API： 序号 URI HTTP 方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 获取用户列表：以下代码，我们创建了 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Express 框架","date":"2017-07-27T01:42:11.000Z","path":"2017/07/27/node17/","text":"Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性：可以设置中间件来响应 HTTP 请求。定义了路由表用于执行不同的 HTTP 请求动作。可以通过向模板传递参数来动态渲染 HTML 页面。 安装 Express首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。12$ mkdir myapp$ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。1$ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来安装 Express 并将其保存到依赖列表中：1$ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：1$ npm install express 安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。实例进入 myapp 目录，创建一个名为 app.js 的文件，然后将下列代码复制进去：12345678910111213var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。通过如下命令启动此应用：1$ node app.js 然后在浏览器中打开 http://localhost:3000/ 并查看输出结果。 express官网 http://www.expressjs.com.cn/","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Web 模块","date":"2017-07-27T01:20:12.000Z","path":"2017/07/27/node16/","text":"什么是 Web 服务器？Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL，与客户端的网络浏览器配合。大多数 web 服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。目前最主流的三个Web服务器是Apache、Nginx、IIS。 Web 应用架构Client - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。Server - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。Business - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。Data - 数据层，一般由数据库组成。 使用 Node 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：1var http = require('http'); 以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示：1234567891011121314151617181920212223242526272829var http = require('http');var fs = require('fs');var url = require('url');// 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log(\"Request for \" + pathname + \" received.\"); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;);&#125;).listen(8081);// 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8081/'); 接下来我们在该目录下创建一个 index.htm 文件，代码如下：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 执行 server.js 文件：12$ node server.jsServer running at http://127.0.0.1:8081/ 接着我们在浏览器中打开地址：http://127.0.0.1:8081/index.htm 执行 server.js 的控制台输出信息如下：123$ node server.jsServer running at http://127.0.0.1:8081/Request for /index.htm received.","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 工具模块","date":"2017-07-21T10:43:09.000Z","path":"2017/07/21/node15/","text":"在 Node.js 模块库中有很多好用的模块。 OS 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：1var os = require(\"os\") 方法 os.tmpdir()返回操作系统的默认临时文件夹。 os.endianness()返回 CPU 的字节序，可能的是 “BE” 或 “LE”。 os.hostname()返回操作系统的主机名。 os.type()返回操作系统名 os.platform()返回操作系统名 os.arch()返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。 os.release()返回操作系统的发行版本。 os.uptime()返回操作系统运行的时间，以秒为单位。 os.loadavg()返回一个包含 1、5、15 分钟平均负载的数组。 os.totalmem()返回系统内存总量，单位为字节。 os.freemem()返回操作系统空闲内存量，单位是字节。 os.cpus()返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。 os.networkInterfaces()获得网络接口列表。 属性 os.EOL定义了操作系统的行尾符的常量。 实例创建 main.js 文件，代码如下所示：1234567891011var os = require(\"os\");// CPU 的字节序console.log('endianness : ' + os.endianness());// 操作系统名console.log('type : ' + os.type());// 操作系统名console.log('platform : ' + os.platform());// 系统内存总量console.log('total memory : ' + os.totalmem() + \" bytes.\");// 操作系统空闲内存量console.log('free memory : ' + os.freemem() + \" bytes.\"); 代码执行结果如下：123456$ node main.jsendianness : LEtype : Windows_NTplatform : win32total memory : 4221722624 bytes.free memory : 1954045952 bytes. Path 模块提供了处理和转换文件路径的工具,我们可以通过以下方式引入该模块： 方法 path.normalize(p)规范化路径，注意’..’ 和 ‘.’。 path.join([path1][, path2][, …])用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\”。 path.resolve([from …], to)将 to 参数解析为绝对路径。 path.isAbsolute(path)判断参数 path 是否是绝对路径。 path.relative(from, to)用于将相对路径转为绝对路径。 path.dirname(p)返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。 path.basename(p[, ext])返回路径中的最后一部分。同 Unix 命令 bashname 类似。 path.extname(p)返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。 path.parse(pathString)返回路径字符串的对象。 path.format(pathObject)从对象中返回路径字符串，和 path.parse 相反。 属性 path.sep平台的文件路径分隔符，’\\‘ 或 ‘/‘。 path.delimiter平台的分隔符, ; or ‘:’. path.posix提供上述 path 的方法，不过总是以 posix 兼容的方式交互。 path.win32提供上述 path 的方法，不过总是以 win32 兼容的方式交互。 实例创建 main.js 文件，代码如下所示：123456789var path = require(\"path\");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));// 连接路径console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));// 转换为绝对路径console.log('resolve : ' + path.resolve('main.js'));// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js')); 代码执行结果如下：12345$ node main.jsnormalization : \\test\\test1\\2slashes\\1slashjoint path : \\test\\test1\\2slashes\\1slashresolve : F:\\Node\\13 工具模块\\path\\main.jsext name : .js Net 模块用于底层的网络通信。提供了服务端和客户端的的操作。我们可以通过以下方式引入该模块：1var net = require(\"net\") 方法 net.createServer([options][, connectionListener])创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。 net.connect(options[, connectionListener])返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。当 socket 建立的时候，将会触发 ‘connect’ 事件。 net.createConnection(options[, connectionListener])创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。 net.connect(port[, host][, connectListener])创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。 net.createConnection(port[, host][, connectListener])创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。 net.connect(path[, connectListener])创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。 net.createConnection(path[, connectListener])创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。 net.isIP(input)检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。 net.isIPv4(input)如果输入的地址为 IPV4， 返回 true，否则返回 false。 net.isIPv6(input)如果输入的地址为 IPV6， 返回 true，否则返回 false。 net.Servernet.Server通常用于创建一个 TCP 或本地服务器。 server.listen(port[, host][, backlog][, callback])监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。 server.listen(path[, callback])通过指定 path 的连接，启动一个本地 socket 服务器。 server.listen(handle[, callback])通过指定句柄连接。 server.listen(options[, callback])options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。 server.close([callback])服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。 server.address()操作系统返回绑定的地址，协议族名和服务器端口。 server.unref()如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。 server.ref()与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。 server.getConnections(callback)异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。 事件 listening当服务器调用 server.listen 绑定后会触发。 connection当新连接创建后会被触发。socket 是 net.Socket实例。 close服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。 error发生错误时触发。’close’ 事件将被下列事件直接调用。 net.Socketnet.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。事件net.Socket 事件有： lookup在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。 connect成功建立 socket 连接时触发。 data当接收到数据时触发。 end当 socket 另一端发送 FIN 包时，触发该事件。 timeout当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。 drain当写缓存为空得时候触发。可用来控制上传。 error错误发生时触发。 close当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。 属性net.Socket 提供了很多有用的属性，便于控制 socket 交互： socket.bufferSize该属性显示了要写入缓冲区的字节数。 socket.remoteAddress远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。 socket.remoteFamily远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。 socket.remotePort远程端口，数字表示，例如：80 or 21。 socket.localAddress网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。 socket.localPort本地端口地址，数字表示。例如：80 or 21。 socket.bytesRead接收到得字节数。 socket.bytesWritten发送的字节数。方法 new net.Socket([options])构造一个新的 socket 对象。 socket.connect(port[, host][, connectListener])指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。 socket.connect(path[, connectListener])打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。 socket.setEncoding([encoding])设置编码 socket.write(data[, encoding][, callback])在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。 socket.end([data][, encoding])半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。 socket.destroy()确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。 socket.pause()暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。 socket.resume()调用 pause() 后想恢复读取数据。 socket.setTimeout(timeout[, callback])socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。 socket.setNoDelay([noDelay])禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。 socket.setKeepAlive([enable][, initialDelay])禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0. socket.address()操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。 socket.unref()如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。 socket.ref()与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。 实例创建 server.js 文件，代码如下所示：123456789101112var net = require('net');var server = net.createServer(function(connection) &#123; console.log('client connected'); connection.on('end', function() &#123; console.log('客户端关闭连接'); &#125;); connection.write('Hello World!\\r\\n'); connection.pipe(connection);&#125;);server.listen(8080, function() &#123; console.log('server is listening');&#125;); 执行以上服务端代码：12$ node server.jsserver is listening # 服务已创建并监听 8080 端口 新开一个窗口，创建 client.js 文件，代码如下所示：1234567891011var net = require('net');var client = net.connect(&#123;port: 8080&#125;, function() &#123; console.log('连接到服务器！'); &#125;);client.on('data', function(data) &#123; console.log(data.toString()); client.end();&#125;);client.on('end', function() &#123; console.log('断开与服务器的连接');&#125;); 执行以上客户端的代码：123连接到服务器！Hello World!断开与服务器的连接 DNS 模块用于解析域名。引入 DNS 模块语法格式如下：1var dns = require(\"dns\") 方法 dns.lookup(hostname[, options], callback)将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。 dns.lookupService(address, port, callback)使用 getnameinfo 解析传入的地址和端口为域名和服务。 dns.resolve(hostname[, rrtype], callback)将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。 dns.resolve4(hostname, callback)和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。 dns.resolve6(hostname, callback)和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询） dns.resolveMx(hostname, callback)和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。 dns.resolveTxt(hostname, callback)和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。 dns.resolveSrv(hostname, callback)和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。 dns.resolveSoa(hostname, callback)和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。 dns.resolveNs(hostname, callback)和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。 dns.resolveCname(hostname, callback)和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。 dns.reverse(ip, callback)反向解析 IP 地址，指向该 IP 地址的域名数组。 dns.getServers()返回一个用于当前解析的 IP 地址数组的字符串。 dns.setServers(servers)指定一组 IP 地址作为解析服务器。 rrtypes以下列出了 dns.resolve() 方法中有效的 rrtypes值:‘A’ IPV4 地址, 默认‘AAAA’ IPV6 地址‘MX’ 邮件交换记录‘TXT’ text 记录‘SRV’ SRV 记录‘PTR’ 用来反向 IP 查找‘NS’ 域名服务器记录‘CNAME’ 别名记录‘SOA’ 授权记录的初始值 错误码每次 DNS 查询都可能返回以下错误码：dns.NODATA: 无数据响应。dns.FORMERR: 查询格式错误。dns.SERVFAIL: 常规失败。dns.NOTFOUND: 没有找到域名。dns.NOTIMP: 未实现请求的操作。dns.REFUSED: 拒绝查询。dns.BADQUERY: 查询格式错误。dns.BADNAME: 域名格式错误。dns.BADFAMILY: 地址协议不支持。dns.BADRESP: 回复格式错误。dns.CONNREFUSED: 无法连接到 DNS 服务器。dns.TIMEOUT: 连接 DNS 服务器超时。dns.EOF: 文件末端。dns.FILE: 读文件错误。dns.NOMEM: 内存溢出。dns.DESTRUCTION: 通道被摧毁。dns.BADSTR: 字符串格式错误。dns.BADFLAGS: 非法标识符。dns.NONAME: 所给主机不是数字。dns.BADHINTS: 非法HINTS标识符。dns.NOTINITIALIZED: c c-ares 库尚未初始化。dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。dns.CANCELLED: 取消 DNS 查询。 实例创建 main.js 文件，代码如下所示：1234567891011var dns = require('dns');dns.lookup('www.github.com', function onLookup(err, address, family) &#123; console.log('ip 地址:', address); dns.reverse(address, function (err, hostnames) &#123; if (err) &#123; console.log(err.stack); &#125; console.log('反向解析 ' + address + ': ' + JSON.stringify(hostnames));&#125;); &#125;); 执行以上代码，结果如下所示:address: 192.30.252.130reverse for 192.30.252.130: [“github.com”] Domain 模块简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。引入 Domain 模块语法格式如下：1var domain = require(\"domain\") domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(‘uncaughtException’)不同。Domain 模块可分为隐式绑定和显式绑定： 隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象 显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象 方法 domain.run(function)在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。 domain.add(emitter)显式的增加事件 domain.remove(emitter)删除事件。 domain.bind(callback)返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。 domain.intercept(callback)和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。 domain.enter()进入一个异步调用的上下文，绑定到domain。 domain.exit()退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。 domain.dispose()释放一个domain对象，让node进程回收这部分资源。 domain.create()返回一个domain对象。 属性 domain.members已加入domain对象的域定时器和事件发射器的数组。 实例创建 main.js 文件，代码如下所示：123456789101112131415161718192021222324252627var EventEmitter = require(\"events\").EventEmitter;var domain = require(\"domain\");var emitter1 = new EventEmitter();// 创建域var domain1 = domain.create();domain1.on('error', function(err)&#123; console.log(\"domain1 处理这个错误 (\"+err.message+\")\");&#125;);// 显式绑定domain1.add(emitter1);emitter1.on('error',function(err)&#123; console.log(\"监听器处理此错误 (\"+err.message+\")\");&#125;);emitter1.emit('error',new Error('通过监听器来处理'));emitter1.removeAllListeners('error');emitter1.emit('error',new Error('通过 domain1 处理'));var domain2 = domain.create();domain2.on('error', function(err)&#123; console.log(\"domain2 处理这个错误 (\"+err.message+\")\");&#125;);// 隐式绑定domain2.run(function()&#123; var emitter2 = new EventEmitter(); emitter2.emit('error',new Error('通过 domain2 处理'));&#125;);domain1.remove(emitter1);emitter1.emit('error', new Error('转换为异常，系统将崩溃!')); 执行以上代码，结果如下所示:123456789101112131415监听器处理此错误 (通过监听器来处理)domain1 处理这个错误 (通过 domain1 处理)domain2 处理这个错误 (通过 domain2 处理)events.js:72 throw er; // Unhandled 'error' event ^Error: 转换为异常，系统将崩溃! at Object.&lt;anonymous&gt; (/www/node/main.js:40:24) at Module._compile (module.js:456:26) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:929:3","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js GET/POST请求","date":"2017-07-20T13:04:31.000Z","path":"2017/07/20/node14/","text":"在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。表单提交到服务器一般都使用 GET/POST 请求。 获取GET请求内容由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js 中 url 模块中的 parse 函数提供了这个功能。1234567var http = require('http');var url = require('url');var util = require('util');http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain; charset=utf-8'&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 获取 URL 的参数我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下：123456789101112var http = require('http');var url = require('url');var util = require('util');http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 解析 url 参数 var params = url.parse(req.url, true).query; res.write(\"网站名：\" + params.name); res.write(\"\\n\"); res.write(\"网站 URL：\" + params.url); res.end();&#125;).listen(3000); 获取 POST 请求内容POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。基本语法结构说明1234567891011121314151617var http = require('http');var querystring = require('querystring');http.createServer(function(req, res)&#123; // 定义了一个post变量，用于暂存请求体的信息 var post = ''; // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 req.on('data', function(chunk)&#123; post += chunk; &#125;); // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 req.on('end', function()&#123; post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000); 以下实例表单通过 POST 提交并输出数据：1234567891011121314151617181920212223242526272829303132var http = require('http');var querystring = require('querystring');var postHTML = '&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Node.js 实例&lt;/title&gt;&lt;/head&gt;' + '&lt;body&gt;' + '&lt;form method=\"post\"&gt;' + '网站名： &lt;input name=\"name\"&gt;&lt;br&gt;' + '网站 URL： &lt;input name=\"url\"&gt;&lt;br&gt;' + '&lt;input type=\"submit\"&gt;' + '&lt;/form&gt;' + '&lt;/body&gt;&lt;/html&gt;';http.createServer(function (req, res) &#123; var body = \"\"; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; // 解析参数 body = querystring.parse(body); // 设置响应头部信息及编码 res.writeHead(200, &#123;'Content-Type': 'text/html; charset=utf8'&#125;); if(body.name &amp;&amp; body.url) &#123; // 输出提交的数据 res.write(\"网站名：\" + body.name); res.write(\"&lt;br&gt;\"); res.write(\"网站 URL：\" + body.url); &#125; else &#123; // 输出表单 res.write(postHTML); &#125; res.end(); &#125;);&#125;).listen(3000);","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 文件系统","date":"2017-07-20T13:04:23.000Z","path":"2017/07/20/node13/","text":"Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：1var fs = require(\"fs\") 异步和同步Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的fs.readFile()和同步的fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。实例创建 input.txt 文件，内容如下：12又见花田半亩文件读取实例 创建 file.js 文件, 代码如下：123456789101112var fs = require(\"fs\");// 异步读取fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"异步读取: \" + data.toString());&#125;);// 同步读取var data = fs.readFileSync('input.txt');console.log(\"同步读取: \" + data.toString());console.log(\"程序执行完毕。\"); 以上代码执行结果如下：123456$ node file.js同步读取: 又见花田半亩文件读取实例程序执行完毕。异步读取: 又见花田半亩文件读取实例 接下来，让我们来具体了解下 Node.js 文件系统的方法 打开文件语法以下为在异步模式下打开文件的语法格式：1fs.open(path, flags[, mode], callback) 参数path - 文件的路径。flags - 文件打开的行为。具体值详见下文。mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。callback - 回调函数，带有两个参数如：callback(err, fd)。 flags 参数可以是以下值： r 以读取模式打开文件。如果文件不存在抛出异常。 r+ 以读写模式打开文件。如果文件不存在抛出异常。 rs 以同步的方式读取文件。 rs+ 以同步的方式读取和写入文件。 w 以写入模式打开文件，如果文件不存在则创建。 wx 类似 ‘w’，但是如果文件路径存在，则文件写入失败。 w+ 以读写模式打开文件，如果文件不存在则创建。 wx+ 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。 a 以追加模式打开文件，如果文件不存在则创建。 ax 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。 a+ 以读取追加模式打开文件，如果文件不存在则创建。 ax+ 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 实例接下来我们创建 file.js 文件，并打开 input.txt 文件进行读写，代码如下所示：123456789var fs = require(\"fs\");// 异步打开文件console.log(\"准备打开文件！\");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件打开成功！\");&#125;); 以上代码执行结果如下：123$ node file.js准备打开文件！文件打开成功！ 获取文件信息语法以下为通过异步模式获取文件信息的语法格式：1fs.stat(path, callback) 参数 path - 文件路径。 callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。 fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：1234var fs = require('fs');fs.stat('/Users/liuht/code/itbilu/demo/fs.js', function (err, stats) &#123; console.log(stats.isFile()); //true&#125;) stats.isFile() 如果是文件返回 true，否则返回 false。stats.isDirectory() 如果是目录返回 true，否则返回 false。stats.isBlockDevice() 如果是块设备返回 true，否则返回 false。stats.isCharacterDevice() 如果是字符设备返回 true，否则返回 false。stats.isSymbolicLink() 如果是软链接返回 true，否则返回 false。stats.isFIFO() 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。stats.isSocket() 如果是 Socket 返回 true，否则返回 false。 实例接下来我们创建 file.js 文件，代码如下所示：123456789101112var fs = require(\"fs\");console.log(\"准备打开文件！\");fs.stat('input.txt', function (err, stats) &#123; if (err) &#123; return console.error(err); &#125; console.log(stats); console.log(\"读取文件信息成功！\"); // 检测文件类型 console.log(\"是否为文件(isFile) ? \" + stats.isFile()); console.log(\"是否为目录(isDirectory) ? \" + stats.isDirectory());&#125;); 以上代码执行结果如下：123456789101112131415161718$ node file.js准备打开文件！&#123; dev: 16777220, mode: 33188, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4096, ino: 40333161, size: 61, blocks: 8, atime: Mon Sep 07 2015 17:43:55 GMT+0800 (CST), mtime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST), ctime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST) &#125;读取文件信息成功！是否为文件(isFile) ? true是否为目录(isDirectory) ? false 写入文件语法以下为异步模式下写入文件的语法格式：1fs.writeFile(file, data[, options], callback) 如果文件存在，该方法写入的内容会覆盖旧的文件内容。参数 file - 文件名或文件描述符。 data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。 options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’ callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。 实例接下来我们创建 file.js 文件，代码如下所示：12345678910111213141516var fs = require(\"fs\");console.log(\"准备写入文件\");fs.writeFile('input.txt', '我是通过写入的文件内容！', function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"数据写入成功！\"); console.log(\"--------我是分割线-------------\") console.log(\"读取写入的数据！\"); fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"异步读取文件数据: \" + data.toString()); &#125;);&#125;); 以上代码执行结果如下：123456$ node file.js准备写入文件数据写入成功！--------我是分割线-------------读取写入的数据！异步读取文件数据: 我是通过写入的文件内容！ 读取文件语法以下为异步模式下读取文件的语法格式：1fs.read(fd, buffer, offset, length, position, callback) 该方法使用了文件描述符来读取文件。参数fd - 通过 fs.open() 方法返回的文件描述符。buffer - 数据写入的缓冲区。offset - 缓冲区写入的写入偏移量。length - 要从文件中读取的字节数。position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。实例input.txt 文件内容为：1哈喽呀，你好呀 接下来我们创建 file.js 文件，代码如下所示：1234567891011121314151617181920var fs = require(\"fs\");var buf = new Buffer(1024);console.log(\"准备打开已存在的文件！\");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件打开成功！\"); console.log(\"准备读取文件：\"); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; console.log(bytes + \" 字节被读取\"); // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; &#125;);&#125;); 以上代码执行结果如下：123456$ node file.js准备打开已存在的文件！文件打开成功！准备读取文件：24 字节被读取哈喽呀，你好呀 关闭文件语法以下为异步模式下关闭文件的语法格式：1fs.close(fd, callback) 该方法使用了文件描述符来读取文件。参数使用说明如下： fd - 通过 fs.open() 方法返回的文件描述符。 callback - 回调函数，没有参数。 实例input.txt 文件内容为：1哈喽呀，你好呀 接下来我们创建 file.js 文件，代码如下所示：1234567891011121314151617181920212223242526var fs = require(\"fs\");var buf = new Buffer(1024);console.log(\"准备打开文件！\");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件打开成功！\"); console.log(\"准备读取文件！\"); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; // 关闭文件 fs.close(fd, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log(\"文件关闭成功\"); &#125;); &#125;);&#125;); 以上代码执行结果如下：123456$ node file.js准备打开文件！文件打开成功！准备读取文件！哈喽呀，你好呀文件关闭成功 截取文件语法以下为异步模式下截取文件的语法格式：1fs.ftruncate(fd, len, callback) 该方法使用了文件描述符来读取文件。参数 fd - 通过 fs.open() 方法返回的文件描述符。 len - 文件内容截取的长度。 callback - 回调函数，没有参数。实例input.txt 文件内容为：1www.baidu.com 接下来我们创建 file.js 文件，代码如下所示：12345678910111213141516171819202122232425262728293031323334var fs = require(\"fs\");var buf = new Buffer(1024);console.log(\"准备打开文件！\");fs.open('input.txt', 'r+', function(err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件打开成功！\"); console.log(\"截取10字节后的文件内容。\"); // 截取文件 fs.ftruncate(fd, 10, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log(\"文件截取成功。\"); console.log(\"读取相同的文件\"); fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123; if (err)&#123; console.log(err); &#125; // 仅输出读取的字节 if(bytes &gt; 0)&#123; console.log(buf.slice(0, bytes).toString()); &#125; // 关闭文件 fs.close(fd, function(err)&#123; if (err)&#123; console.log(err); &#125; console.log(\"文件关闭成功！\"); &#125;); &#125;); &#125;);&#125;); 以上代码执行结果如下：12345678$ node file.js准备打开文件！文件打开成功！截取10字节后的文件内容。文件截取成功。读取相同的文件www.bai文件关闭成功！ 删除文件语法以下为删除文件的语法格式：1fs.unlink(path, callback) 参数 path - 文件路径。 callback - 回调函数，没有参数。实例input.txt 文件内容为：1www.baidu.com 接下来我们创建 file.js 文件，代码如下所示：12345678var fs = require(\"fs\");console.log(\"准备删除文件！\");fs.unlink('input.txt', function(err) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件删除成功！\");&#125;); 以上代码执行结果如下：123$ node file.js准备删除文件！文件删除成功！ 再去查看 input.txt 文件，发现已经不存在了。 创建目录语法以下为创建目录的语法格式：1fs.mkdir(path[, mode], callback) 参数 path - 文件路径。 mode - 设置目录权限，默认为 0777。 callback - 回调函数，没有参数。实例接下来我们创建 file.js 文件，代码如下所示：12345678910var fs = require(\"fs\");console.log(\"查看 /tmp 目录\");fs.readdir(\"/tmp/\",function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;);&#125;); 以上代码执行结果如下：123456$ node file.js查看 /tmp 目录input.outoutput.outtesttest.txt 删除目录语法以下为删除目录的语法格式：1fs.rmdir(path, callback) 参数path - 文件路径。callback - 回调函数，没有参数。实例接下来我们创建 file.js 文件，代码如下所示：1234567891011121314151617var fs = require(\"fs\");// 执行前创建一个空的 /tmp/test 目录console.log(\"准备删除目录 /tmp/test\");fs.rmdir(\"/tmp/test\",function(err)&#123; if (err) &#123; return console.error(err); &#125; console.log(\"读取 /tmp 目录\"); fs.readdir(\"/tmp/\",function(err, files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach( function (file)&#123; console.log( file ); &#125;); &#125;);&#125;); 以上代码执行结果如下：1234$ node file.js准备删除目录 /tmp/test读取 /tmp 目录…… 文件模块方法参考手册以下为 Node.js 文件模块相同的方法列表：1 fs.rename(oldPath, newPath, callback)异步 rename().回调函数没有参数，但可能抛出异常。2 fs.ftruncate(fd, len, callback)异步 ftruncate().回调函数没有参数，但可能抛出异常。3 fs.ftruncateSync(fd, len)同步 ftruncate()4 fs.truncate(path, len, callback)异步 truncate().回调函数没有参数，但可能抛出异常。5 fs.truncateSync(path, len)同步 truncate()6 fs.chown(path, uid, gid, callback)异步 chown().回调函数没有参数，但可能抛出异常。7 fs.chownSync(path, uid, gid)同步 chown()8 fs.fchown(fd, uid, gid, callback)异步 fchown().回调函数没有参数，但可能抛出异常。9 fs.fchownSync(fd, uid, gid)同步 fchown()10 fs.lchown(path, uid, gid, callback)异步 lchown().回调函数没有参数，但可能抛出异常。11 fs.lchownSync(path, uid, gid)同步 lchown()12 fs.chmod(path, mode, callback)异步 chmod().回调函数没有参数，但可能抛出异常。13 fs.chmodSync(path, mode)同步 chmod().14 fs.fchmod(fd, mode, callback)异步 fchmod().回调函数没有参数，但可能抛出异常。15 fs.fchmodSync(fd, mode)同步 fchmod().16 fs.lchmod(path, mode, callback)异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.17 fs.lchmodSync(path, mode)同步 lchmod().18 fs.stat(path, callback)异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。19 fs.lstat(path, callback)异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。20 fs.fstat(fd, callback)异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。21 fs.statSync(path)同步 stat(). 返回 fs.Stats 的实例。22 fs.lstatSync(path)同步 lstat(). 返回 fs.Stats 的实例。23 fs.fstatSync(fd)同步 fstat(). 返回 fs.Stats 的实例。24 fs.link(srcpath, dstpath, callback)异步 link().回调函数没有参数，但可能抛出异常。25 fs.linkSync(srcpath, dstpath)同步 link().26 fs.symlink(srcpath, dstpath[, type], callback)异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。27 fs.symlinkSync(srcpath, dstpath[, type])同步 symlink().28 fs.readlink(path, callback)异步 readlink(). 回调函数有两个参数 err, linkString。29 fs.realpath(path[, cache], callback)异步 realpath(). 回调函数有两个参数 err, resolvedPath。30 fs.realpathSync(path[, cache])同步 realpath()。返回绝对路径。31 fs.unlink(path, callback)异步 unlink().回调函数没有参数，但可能抛出异常。32 fs.unlinkSync(path)同步 unlink().33 fs.rmdir(path, callback)异步 rmdir().回调函数没有参数，但可能抛出异常。34 fs.rmdirSync(path)同步 rmdir().35 fs.mkdir(path[, mode], callback)S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 mode defaults to 0777.36 fs.mkdirSync(path[, mode])同步 mkdir().37 fs.readdir(path, callback)异步 readdir(3). 读取目录的内容。38 fs.readdirSync(path)同步 readdir().返回文件数组列表。39 fs.close(fd, callback)异步 close().回调函数没有参数，但可能抛出异常。40 fs.closeSync(fd)同步 close().41 fs.open(path, flags[, mode], callback)异步打开文件。42 fs.openSync(path, flags[, mode])同步 version of fs.open().43 fs.utimes(path, atime, mtime, callback) 44 fs.utimesSync(path, atime, mtime)修改文件时间戳，文件通过指定的文件路径。45 fs.futimes(fd, atime, mtime, callback) 46 fs.futimesSync(fd, atime, mtime)修改文件时间戳，通过文件描述符指定。47 fs.fsync(fd, callback)异步 fsync.回调函数没有参数，但可能抛出异常。48 fs.fsyncSync(fd)同步 fsync.49 fs.write(fd, buffer, offset, length[, position], callback)将缓冲区内容写入到通过文件描述符指定的文件。50 fs.write(fd, data[, position[, encoding]], callback)通过文件描述符 fd 写入文件内容。51 fs.writeSync(fd, buffer, offset, length[, position])同步版的 fs.write()。52 fs.writeSync(fd, data[, position[, encoding]])同步版的 fs.write().53 fs.read(fd, buffer, offset, length, position, callback)通过文件描述符 fd 读取文件内容。54 fs.readSync(fd, buffer, offset, length, position)同步版的 fs.read.55 fs.readFile(filename[, options], callback)异步读取文件内容。56 fs.readFileSync(filename[, options])57 fs.writeFile(filename, data[, options], callback)异步写入文件内容。58 fs.writeFileSync(filename, data[, options])同步版的 fs.writeFile。59 fs.appendFile(filename, data[, options], callback)异步追加文件内容。60 fs.appendFileSync(filename, data[, options])The 同步 version of fs.appendFile.61 fs.watchFile(filename[, options], listener)查看文件的修改。62 fs.unwatchFile(filename[, listener])停止查看 filename 的修改。63 fs.watch(filename[, options][, listener])查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。64 fs.exists(path, callback)检测给定的路径是否存在。65 fs.existsSync(path)同步版的 fs.exists.66 fs.access(path[, mode], callback)测试指定路径用户权限。67 fs.accessSync(path[, mode])同步版的 fs.access。68 fs.createReadStream(path[, options])返回ReadStream 对象。69 fs.createWriteStream(path[, options])返回 WriteStream 对象。70 fs.symlink(srcpath, dstpath[, type], callback)异步 symlink().回调函数没有参数，但可能抛出异常。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 常用工具","date":"2017-07-20T13:04:16.000Z","path":"2017/07/20/node12/","text":"util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript的功能过于精简的不足。 util.inheritsutil.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。JavaScript的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript没有提供对象继承的语言级别特性，而是通过原型复制来实现的。实例创建文件 main.js ，代码如下所示：1234567891011121314151617181920212223var util = require('util');function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;;&#125;Base.prototype.showName = function() &#123; console.log(this.name);&#125;;function Sub() &#123; this.name = 'sub';&#125;util.inherits(Sub, Base);var objBase = new Base();objBase.showName();objBase.sayHello();console.log(objBase);var objSub = new Sub();objSub.showName();//objSub.sayHello();console.log(objSub); 我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承,执行 main.js 文件，代码如下所示:123456$ node main.jsbaseHello baseBase &#123; name: 'base', base: 1991, sayHello: [Function] &#125;subSub &#123; name: 'sub' &#125; 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：12345678910111213141516171819$ node main.jsbaseHello baseBase &#123; name: 'base', base: 1991, sayHello: [Function] &#125;subF:\\Node\\11 常用工具\\main.js:22objSub.sayHello(); ^TypeError: objSub.sayHello is not a function at Object.&lt;anonymous&gt; (F:\\Node\\11 常用工具\\main.js:22:8) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9) at bootstrap_node.js:509:3 util.inspectutil.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。12345678910var util = require('util');function Person() &#123; this.name = 'byvoid'; this.toString = function() &#123; return this.name; &#125;;&#125;var obj = new Person();console.log(util.inspect(obj));console.log(util.inspect(obj, true)); 运行结果是：12345678910Person &#123; name: 'byvoid', toString: [Function] &#125;Person &#123; name: 'byvoid', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArray(object)如果给定的参数 “object” 是一个数组返回true，否则返回false。1234567var util = require('util');util.isArray([]) // trueutil.isArray(new Array) // trueutil.isArray(&#123;&#125;) // false util.isRegExp(object)如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。1234567var util = require('util');util.isRegExp(/some regexp/) // trueutil.isRegExp(new RegExp('another regexp')) // trueutil.isRegExp(&#123;&#125;) // false util.isDate(object)如果给定的参数 “object” 是一个日期返回true，否则返回false1234567var util = require('util');util.isDate(new Date()) // trueutil.isDate(Date()) // false (without 'new' returns a String)util.isDate(&#123;&#125;) // false util.isError(object)如果给定的参数 “object” 是一个错误对象返回true，否则返回false。1234567var util = require('util');util.isError(new Error()) // trueutil.isError(new TypeError()) // trueutil.isError(&#123; name: 'Error', message: 'an error occurred' &#125;) // false","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 全局对象","date":"2017-07-20T13:03:52.000Z","path":"2017/07/20/node11/","text":"JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它 全局对象与全局变量global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量是全局变量： 在最外层定义的变量； 全局对象的属性； 隐式定义的变量（未定义直接赋值的变量）。 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。 __filename表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径实例创建文件 main.js ，代码如下所示：12// 输出全局变量 __filename 的值console.log( __filename ); 执行 main.js 文件，代码如下所示:12$ node main.jsF:\\Node\\10 全局对象\\main.js __dirname表示当前执行脚本所在的目录。实例创建文件 main.js ，代码如下所示：12// 输出全局变量 __filename 的值console.log( __dirname ); 执行 main.js 文件，代码如下所示:12$ node main.jsF:\\Node\\10 全局对象 setTimeout(cb, ms)setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。返回一个代表定时器的句柄值。实例创建文件 main.js ，代码如下所示：12345function printHello()&#123; console.log( \"Hello, World!\");&#125;// 两秒后执行以上函数setTimeout(printHello, 2000); 执行 main.js 文件，代码如下所示:12$ node main.jsHello, World! clearTimeout(t)clearTimeout( t )全局函数用于停止一个之前通过setTimeout()创建的定时器。 参数t是通过 setTimeout()函数创建的定时器。1234567function printHello()&#123; console.log( \"Hello, World!\");&#125;// 两秒后执行以上函数var t = setTimeout(printHello, 2000);// 清除定时器clearTimeout(t); 执行 main.js 文件，代码如下所示:1$ node main.js setInterval(cb, ms)setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。实例创建文件 main.js ，代码如下所示：12345function printHello()&#123; console.log( \"Hello, World!\");&#125;// 两秒后执行以上函数setInterval(printHello, 2000); 执行 main.js 文件，代码如下所示:1$ node main.js Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! ……以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。 consoleconsole 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。 console 方法以下为 console 对象的方法: console.log([data][, …])向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。 console.info([data][, …])该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。 console.error([data][, …])输出错误消息的。控制台在出现错误时会显示是红色的叉子。 console.warn([data][, …])输出警告消息。控制台出现有黄色的惊叹号。 console.dir(obj[, options])用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.time(label)输出时间，表示计时开始。 console.timeEnd(label)结束时间，表示计时结束。 console.trace(message[, …])当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。 console.assert(value[, message][, …])用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。console.log()：向标准输出流打印字符并以换行符结束。console.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。第一个参数是一个字符串，如果没有 参数，只打印一个换行。 console.log()：向标准输出流打印字符并以换行符结束。console.log 接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。第一个参数是一个字符串，如果没有 参数，只打印一个换行。123console.log('Hello world');console.log('byvoid%diovyb');console.log('byvoid%diovyb', 1991); 运行结果为：123Hello worldbyvoid%diovybbyvoid1991iovyb console.error()：与console.log() 用法相同，只是向标准错误流输出。console.trace()：向标准错误流输出当前的调用栈。1console.trace(); 运行结果为：12345678Trace:at Object.&lt;anonymous&gt; (/home/byvoid/consoletrace.js:1:71)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 实例创建文件 main.js ，代码如下所示：123456789console.info(\"程序开始执行：\");var counter = 10;console.log(\"计数: %d\", counter);console.time(\"获取数据\");//// 执行一些代码//console.timeEnd('获取数据');console.info(\"程序执行完毕。\"); 执行 main.js 文件，代码如下所示:12345$ node main.js程序开始执行：计数: 10获取数据: 0ms程序执行完毕 processprocess 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。 exit当进程准备退出时触发。 beforeExit当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。 uncaughtException当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。 Signal 事件当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 实例创建文件 main.js ，代码如下所示：12345678process.on('exit', function(code) &#123; // 以下代码永远不会执行 setTimeout(function() &#123; console.log(\"该代码不会执行\"); &#125;, 0); console.log('退出码为:', code);&#125;);console.log(\"程序执行结束\"); 执行 main.js 文件，代码如下所示:123$ node main.js程序执行结束退出码为: 0 退出状态码退出状态码如下所示：1——（Uncaught Fatal Exception）有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。2——（Unused）保留3——（Internal JavaScript Parse Error）JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。4——（Internal JavaScript Evaluation Failure）JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。5——（Fatal Error）V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR6——（Non-function Internal Exception Handler）未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。7——（Internal Exception Handler Run-Time Failure）未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。8——（Unused）保留9——（Invalid Argument）可能是给了未知的参数，或者给的参数没有值。10——（Internal JavaScript Run-Time Failure）JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。12——（Invalid Debug Argument）设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。128——（Signal Exits）如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。Process 属性Process 提供了很多有用的属性，便于我们更好的控制系统的交互： stdout标准输出流。 stderr标准错误流。 stdin标准输入流。 argvargv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。 execPath返回执行当前脚本的 Node 二进制文件的绝对路径。 execArgv返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。 env返回一个对象，成员为当前 shell 的环境变量 exitCode进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。 versionNode 的版本，比如v0.10.18。 versions一个属性，包含了 node 的版本和依赖. config一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。 pid当前进程的进程号。 title进程名，默认值为”node”，可以自定义该值 arch当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。 platform运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’ mainModulerequire.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 实例创建文件 main.js ，代码如下所示：12345678910// 输出到终端process.stdout.write(\"Hello World!\" + \"\\n\");// 通过参数读取process.argv.forEach(function(val, index, array) &#123; console.log(index + ': ' + val);&#125;);// 获取执行路径console.log(process.execPath);// 平台信息console.log(process.platform); 执行 main.js 文件，代码如下所示:123456$ node main.jsHello World!0: D:\\nodejs\\node.exe1: F:\\Node\\10 全局对象\\main.jsD:\\nodejs\\node.exewin32 方法参考手册Process 提供了很多有用的方法，便于我们更好的控制系统的交互： abort()这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。 chdir(directory)改变当前工作进程的目录，如果操作失败抛出异常。 cwd()返回当前进程的工作目录 exit([code])使用指定的 code 结束进程。如果忽略，将会使用 code 0。 getgid()获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 setgid(id)设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 getuid()获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 setuid(id)设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 getgroups()返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 setgroups(groups)设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 initgroups(user, extra_group)读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。 kill(pid[, signal])发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。 memoryUsage()返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。 nextTick(callback)一旦当前事件循环结束，调用回到函数。 umask([mask])设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。 uptime()返回 Node 已经运行的秒数。 hrtime()返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。 实例创建文件 main.js ，代码如下所示：123456// 输出当前目录console.log('当前目录: ' + process.cwd());// 输出当前版本console.log('当前版本: ' + process.version);// 输出内存使用情况console.log(process.memoryUsage()); 执行 main.js 文件，代码如下所示:1234567$ node main.js当前目录: F:\\Node\\10 全局对象当前版本: v6.10.0&#123; rss: 17199104, heapTotal: 7376896, heapUsed: 3137464, external: 8236 &#125;","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 路由","date":"2017-07-20T06:52:43.000Z","path":"2017/07/20/node10/","text":"我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块12345678910111213url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring.parse(queryString)[\"foo\"] | | querystring.parse(queryString)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：1234567891011121314var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：1234function route(pathname) &#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去，server.js 文件代码如下123456789101112131415var http = require(\"http\");var url = require(\"url\");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：123var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 在这里，我们传递的函数依旧什么也没做。如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：12$ node index.jsServer has started. 以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分。浏览器访问http://127.0.0.1:8888/","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 函数","date":"2017-07-20T06:52:28.000Z","path":"2017/07/20/node09/","text":"在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：1234567function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 匿名函数我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：1234function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, \"Hello\"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：123456var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。用这样的代码也可以达到同样的目的：1234567var http = require(\"http\");function onRequest(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888);","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js模块系统","date":"2017-07-20T06:52:13.000Z","path":"2017/07/20/node08/","text":"为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 创建模块在 Node.js 中，创建一个模块非常简单，如下我们创建一个 ‘main.js’ 文件，代码如下:12var hello = require('./hello');hello.world(); 以上实例中，代码 require(‘./hello’) 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 接下来我们就来创建hello.js文件，代码如下：123exports.world = function() &#123; console.log('Hello World');&#125; 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。有时候我们只是想把一个对象封装到模块中，格式如下：123module.exports = function() &#123; // ...&#125; 例如:1234567891011//hello.jsfunction Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;;&#125;;module.exports = Hello; 这样就可以直接获得这个对象了：12345//main.jsvar Hello = require('./hello');hello = new Hello();hello.setName('BYVoid');hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 服务端的模块放在哪里也许你已经注意到，我们已经在代码中使用了模块了。像这样：123var http = require(\"http\");...http.createServer(...); Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。Node.js 的 require方法中的文件查找策略如下：由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。 在路径 Y 下执行 require(X) 语句执行顺序：123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 如果 X 是内置模块 a. 返回内置模块 b. 停止执行2. 如果 X 以 '/' 开头 a. 设置 Y 为文件根路径3. 如果 X 以 './' 或 '/' or '../' 开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)4. LOAD_NODE_MODULES(X, dirname(Y))5. 抛出异常 \"not found\"LOAD_AS_FILE(X)1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。LOAD_INDEX(X)1. 如果 X/index.js 是一个文件, 将 X/index.js 作为 JavaScript 文本载入并停止执行。2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。3. 如果 X/index.node 是一个文件, 将 X/index.node 作为二进制插件载入并停止执行。LOAD_AS_DIRECTORY(X)1. 如果 X/package.json 是一个文件, a. 解析 X/package.json, 并查找 \"main\" 字段。 b. let M = X + (json main 字段) c. LOAD_AS_FILE(M) d. LOAD_INDEX(M)2. LOAD_INDEX(X)LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Stream(流)","date":"2017-07-20T06:52:02.000Z","path":"2017/07/20/node07/","text":"Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。Node.js，Stream 的四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 从流中读取数据创建 input.txt 文件，内容如下：1又见花田半亩 创建 main.js 文件, 代码如下：1234567891011121314151617var fs = require(\"fs\");var data = '';// 创建可读流var readerStream = fs.createReadStream('input.txt');// 设置编码为 utf8。readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data, end, and errorreaderStream.on('data', function(chunk) &#123; data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 执行结果如下：123$ node main.js程序执行完毕又见花田半亩 写入流创建 main.js 文件, 代码如下：1234567891011121314151617//引入require模块var fs = require(\"fs\");var data = '又见花田半亩';// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream('output.txt');// 使用 utf8 编码写入数据writerStream.write(data,'UTF8');// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on('finish', function() &#123; console.log(\"写入完成。\");&#125;);writerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：123$ node main.js程序执行完毕写入完成。 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。设置 input.txt 文件内容如下：12又见花田半亩管道流操作实例 创建 main.js 文件, 代码如下：123456789var fs = require(\"fs\");// 创建一个可读流var readerStream = fs.createReadStream('input.txt');// 创建一个可写流var writerStream = fs.createWriteStream('output.txt');// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(\"程序执行完毕\"); 代码执行结果如下：12$ node main.js程序执行完毕 查看 output.txt 文件的内容：123$ cat output.txt又见花田半亩管道流操作实例 链式流链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建 compress.js 文件, 代码如下：1234567var fs = require(\"fs\");var zlib = require('zlib');// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.zip'));console.log(\"文件压缩完成。\"); 代码执行结果如下：12$ node compress.js文件压缩完成。 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：1234567var fs = require(\"fs\");var zlib = require('zlib');// 解压 input.txt.gz 文件为 input.txtfs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt'));console.log(\"文件解压完成。\"); 代码执行结果如下：12$ node decompress.js文件解压完成。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Buffer(缓冲区)","date":"2017-07-20T06:50:57.000Z","path":"2017/07/20/node06/","text":"JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建Buffer类Node Buffer 类可以通过多种方式来创建。 方法 1创建长度为 10 字节的 Buffer 实例：1var buf = new Buffer(10); 方法 2通过给定的数组创建 Buffer 实例：1var buf = new Buffer([10, 20, 30, 40, 50]); 方法 3通过一个字符串来创建 Buffer 实例：1var buf = new Buffer(\"www.baidu.com\", \"utf-8\"); utf-8 是默认的编码方式，此外它同样支持以下编码：”ascii”, “utf8”, “utf16le”, “ucs2”, “base64” 和 “hex”。 写入缓冲区语法写入 Node 缓冲区的语法如下所示：1buf.write(string[, offset[, length]][, encoding]) 参数 string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例123buf = new Buffer(256);len = buf.write(\"www.runoob.com\");console.log(\"写入字节数 : \"+ len); 输出结果为：12$node main.js写入字节数 : 13 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示：1buf.toString([encoding[, start[, end]]]) 参数 encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例12345678buf = new Buffer(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 输出结果为：12345$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象语法将 Node Buffer 转换为 JSON 对象的函数语法格式如下：1buf.toJSON() 返回值返回 JSON 对象。 实例123var buf = new Buffer('www.baidu.com');var json = buf.toJSON(buf);console.log(json); 输出结果为：1[ 119, 119, 119, 46, 98, 97, 105, 100, 117, 46, 99, 111, 109 ] 缓冲区合并语法Node 缓冲区合并的语法如下所示：1Buffer.concat(list[, totalLength]) 参数 list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值返回一个多个成员合并的新 Buffer 对象。 实例1234var buffer1 = new Buffer('前端菜鸟 ');var buffer2 = new Buffer('www.runoob.com');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(\"buffer3 内容: \" + buffer3.toString()); 输出结果为1buffer3 内容: 前端菜鸟 缓冲区比较语法Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：1buf.compare(otherBuffer); 参数otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象 返回值返回一个数字，表示 buf 在 otherBuffer 之前(result0)或相同(result=0)。 实例12345678910var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");&#125;else if(result == 0)&#123; console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");&#125;else &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");&#125; 输出结果：1ABC在ABCD之前 拷贝缓冲区语法Node 缓冲区拷贝语法如下所示：1buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) 参数 targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值没有返回值。 实例12345var buffer1 = new Buffer('ABC');// 拷贝一个缓冲区var buffer2 = new Buffer(3);buffer1.copy(buffer2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ABC 缓冲区裁剪语法Node 缓冲区裁剪语法如下所示：1buf.slice([start[, end]]) 参数 start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例1234var buffer1 = new Buffer('runoob');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ru 缓冲区长度语法Node 缓冲区长度计算语法如下所示：1buf.length; 返回值返回 Buffer 对象所占据的内存长度。 实例123var buffer = new Buffer('www.baidu.com');// 缓冲区长度console.log(\"buffer length: \" + buffer.length); 输出结果为：1buffer length: 13 方法参考手册new Buffer(size)分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 new Buffer(buffer)拷贝参数 buffer 的数据到 Buffer 实例。 new Buffer(str[, encoding])分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 buf.length返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js EventEmitter","date":"2017-07-20T06:50:44.000Z","path":"2017/07/20/node05/","text":"Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。下面我们用一个简单的例子说明 EventEmitter 的用法：123456789//event.js 文件var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function() &#123; console.log('some_event 事件触发');&#125;);setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 执行结果如下：运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。12$ node event.jssome_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。让我们以下面的例子解释这个过程：12345678910//event.js 文件var events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2);&#125;);emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2);&#125;);emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 执行以上代码，运行的结果如下： 123$ node event.jslistener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部。on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法listenerCount(emitter, event)返回指定事件的监听器数量。 事件newListener(event, listener)event - 字符串，事件名称listener - 处理事件函数该事件在添加新监听器时被触发。 removeListener(event, listener)event - 字符串，事件名称listener - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。创建 main.js 文件，代码如下：1234567891011121314151617181920212223242526var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");// 处理 connection 事件eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log(\"listener1 不再受监听。\");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");console.log(\"程序执行完毕。\"); 运行结果12345678$ node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕。 error事件error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：123var events = require('events');var emitter = new events.EventEmitter();emitter.emit('error'); 运行时会显示以下错误：123456789101112node.js:201throw e; // process.nextTick error, or 'error' event on first tick^Error: Uncaught, unspecified 'error' event.at EventEmitter.emit (events.js:50:15)at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。为什么要这样做呢？原因有两点：首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 事件循环","date":"2017-07-20T06:50:31.000Z","path":"2017/07/20/node04/","text":"Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 实例12345678910111213141516171819// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\"); 接下来让我们执行以上代码：1234$ node main.js连接成功。数据接收成功。程序执行完毕。 Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：1node.js 事件循环 创建 main.js 文件，代码如下：123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：12程序执行完毕node.js 事件循环 接下来我们删除 input.txt 文件，执行结果如下所示：12程序执行完毕Error: ENOENT, open 'input.txt' 因为文件 input.txt 不存在，所以输出了错误信息。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 回调函数","date":"2017-07-20T06:50:16.000Z","path":"2017/07/20/node03/","text":"Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是阻塞模式 创建 main.js 文件, 代码如下： 1234var fs = require(\"fs\");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(\"程序执行结束!\"); 结果：123$ node main.jshello，这是阻塞模式程序执行结束! 非阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是非阻塞模式 创建 main.js 文件, 代码如下： 123456var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"程序执行结束!\"); 结果：123$ node main.js程序执行结束!hello，这是非阻塞模式 总结 我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞调用在文件读取完后才执行完程序。非阻塞调用我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js REPL(交互式解释器)","date":"2017-07-20T06:31:25.000Z","path":"2017/07/20/node02/","text":"Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。 我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 简单的表达式运算123456789101112$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt; 使用变量你可以将数据存储在变量中，并在你需要的时候使用它。变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。使用 var 关键字的变量可以使用 console.log() 来输出变量。 12345678910111213$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(\"Hello World\")Hello Worldundefined&gt; console.log(\"www.baidu.com\")www.baidu.comundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314$ node&gt; var x = 0undefined&gt; do &#123;... x++;... console.log(\"x: \" + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线(_)变量你可以使用下划线(_)获取表达式的运算结果：12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 停止 REPL前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 创建第一个应用","date":"2017-07-20T06:08:00.000Z","path":"2017/07/20/node01/","text":"使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。 node.js应用由哪几部分组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 实例123456789101112//引入 required 模块var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 分析node.js的HTTP服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]}]