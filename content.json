[{"title":"Node.js 路由","date":"2017-07-20T06:52:43.000Z","path":"2017/07/20/node10/","text":"我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块12345678910111213url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring.parse(queryString)[\"foo\"] | | querystring.parse(queryString)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：1234567891011121314var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 好了，我们的应用现在可以通过请求的URL路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以URL路径为基准映射到处理程序上。在我们所要构建的应用中，这意味着来自/start和/upload的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。现在我们可以来编写路由了，建立一个名为 router.js 的文件，添加以下内容：1234function route(pathname) &#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去，server.js 文件代码如下123456789101112131415var http = require(\"http\");var url = require(\"url\");function start(route) &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：123var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 在这里，我们传递的函数依旧什么也没做。如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：12$ node index.jsServer has started. 以上输出已经去掉了比较烦人的/favicon.ico请求相关的部分。浏览器访问http://127.0.0.1:8888/","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 函数","date":"2017-07-20T06:52:28.000Z","path":"2017/07/20/node09/","text":"在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：1234567function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 匿名函数我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：1234function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, \"Hello\"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 函数传递是如何让HTTP服务器工作的带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：123456var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。用这样的代码也可以达到同样的目的：1234567var http = require(\"http\");function onRequest(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;http.createServer(onRequest).listen(8888);","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js模块系统","date":"2017-07-20T06:52:13.000Z","path":"2017/07/20/node08/","text":"为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 创建模块在 Node.js 中，创建一个模块非常简单，如下我们创建一个 ‘main.js’ 文件，代码如下:12var hello = require('./hello');hello.world(); 以上实例中，代码 require(‘./hello’) 引入了当前目录下的hello.js文件（./ 为当前目录，node.js默认后缀为js）。Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 接下来我们就来创建hello.js文件，代码如下：123exports.world = function() &#123; console.log('Hello World');&#125; 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。有时候我们只是想把一个对象封装到模块中，格式如下：123module.exports = function() &#123; // ...&#125; 例如:1234567891011//hello.jsfunction Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;;&#125;;module.exports = Hello; 这样就可以直接获得这个对象了：12345//main.jsvar Hello = require('./hello');hello = new Hello();hello.setName('BYVoid');hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 服务端的模块放在哪里也许你已经注意到，我们已经在代码中使用了模块了。像这样：123var http = require(\"http\");...http.createServer(...); Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。Node.js 的 require方法中的文件查找策略如下：由于Node.js中存在4类模块（原生模块和3种文件模块），尽管require方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。 在路径 Y 下执行 require(X) 语句执行顺序：123456789101112131415161718192021222324252627282930313233343536373839404142434445461. 如果 X 是内置模块 a. 返回内置模块 b. 停止执行2. 如果 X 以 '/' 开头 a. 设置 Y 为文件根路径3. 如果 X 以 './' 或 '/' or '../' 开头 a. LOAD_AS_FILE(Y + X) b. LOAD_AS_DIRECTORY(Y + X)4. LOAD_NODE_MODULES(X, dirname(Y))5. 抛出异常 \"not found\"LOAD_AS_FILE(X)1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。LOAD_INDEX(X)1. 如果 X/index.js 是一个文件, 将 X/index.js 作为 JavaScript 文本载入并停止执行。2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。3. 如果 X/index.node 是一个文件, 将 X/index.node 作为二进制插件载入并停止执行。LOAD_AS_DIRECTORY(X)1. 如果 X/package.json 是一个文件, a. 解析 X/package.json, 并查找 \"main\" 字段。 b. let M = X + (json main 字段) c. LOAD_AS_FILE(M) d. LOAD_INDEX(M)2. LOAD_INDEX(X)LOAD_NODE_MODULES(X, START)1. let DIRS=NODE_MODULES_PATHS(START)2. for each DIR in DIRS: a. LOAD_AS_FILE(DIR/X) b. LOAD_AS_DIRECTORY(DIR/X)NODE_MODULES_PATHS(START)1. let PARTS = path split(START)2. let I = count of PARTS - 13. let DIRS = []4. while I &gt;= 0, a. if PARTS[I] = \"node_modules\" CONTINUE b. DIR = path join(PARTS[0 .. I] + \"node_modules\") c. DIRS = DIRS + DIR d. let I = I - 15. return DIRS","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Stream(流)","date":"2017-07-20T06:52:02.000Z","path":"2017/07/20/node07/","text":"Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。Node.js，Stream 的四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 从流中读取数据创建 input.txt 文件，内容如下：1又见花田半亩 创建 main.js 文件, 代码如下：1234567891011121314151617var fs = require(\"fs\");var data = '';// 创建可读流var readerStream = fs.createReadStream('input.txt');// 设置编码为 utf8。readerStream.setEncoding('UTF8');// 处理流事件 --&gt; data, end, and errorreaderStream.on('data', function(chunk) &#123; data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 执行结果如下：123$ node main.js程序执行完毕又见花田半亩 写入流创建 main.js 文件, 代码如下：1234567891011121314151617//引入require模块var fs = require(\"fs\");var data = '又见花田半亩';// 创建一个可以写入的流，写入到文件 output.txt 中var writerStream = fs.createWriteStream('output.txt');// 使用 utf8 编码写入数据writerStream.write(data,'UTF8');// 标记文件末尾writerStream.end();// 处理流事件 --&gt; data, end, and errorwriterStream.on('finish', function() &#123; console.log(\"写入完成。\");&#125;);writerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：123$ node main.js程序执行完毕写入完成。 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。设置 input.txt 文件内容如下：12又见花田半亩管道流操作实例 创建 main.js 文件, 代码如下：123456789var fs = require(\"fs\");// 创建一个可读流var readerStream = fs.createReadStream('input.txt');// 创建一个可写流var writerStream = fs.createWriteStream('output.txt');// 管道读写操作// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream);console.log(\"程序执行完毕\"); 代码执行结果如下：12$ node main.js程序执行完毕 查看 output.txt 文件的内容：123$ cat output.txt又见花田半亩管道流操作实例 链式流链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。创建 compress.js 文件, 代码如下：1234567var fs = require(\"fs\");var zlib = require('zlib');// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.zip'));console.log(\"文件压缩完成。\"); 代码执行结果如下：12$ node compress.js文件压缩完成。 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：1234567var fs = require(\"fs\");var zlib = require('zlib');// 解压 input.txt.gz 文件为 input.txtfs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt'));console.log(\"文件解压完成。\"); 代码执行结果如下：12$ node decompress.js文件解压完成。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Buffer(缓冲区)","date":"2017-07-20T06:50:57.000Z","path":"2017/07/20/node06/","text":"JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建Buffer类Node Buffer 类可以通过多种方式来创建。 方法 1创建长度为 10 字节的 Buffer 实例：1var buf = new Buffer(10); 方法 2通过给定的数组创建 Buffer 实例：1var buf = new Buffer([10, 20, 30, 40, 50]); 方法 3通过一个字符串来创建 Buffer 实例：1var buf = new Buffer(\"www.baidu.com\", \"utf-8\"); utf-8 是默认的编码方式，此外它同样支持以下编码：”ascii”, “utf8”, “utf16le”, “ucs2”, “base64” 和 “hex”。 写入缓冲区语法写入 Node 缓冲区的语法如下所示：1buf.write(string[, offset[, length]][, encoding]) 参数 string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例123buf = new Buffer(256);len = buf.write(\"www.runoob.com\");console.log(\"写入字节数 : \"+ len); 输出结果为：12$node main.js写入字节数 : 13 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示：1buf.toString([encoding[, start[, end]]]) 参数 encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例12345678buf = new Buffer(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 输出结果为：12345$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象语法将 Node Buffer 转换为 JSON 对象的函数语法格式如下：1buf.toJSON() 返回值返回 JSON 对象。 实例123var buf = new Buffer('www.baidu.com');var json = buf.toJSON(buf);console.log(json); 输出结果为：1[ 119, 119, 119, 46, 98, 97, 105, 100, 117, 46, 99, 111, 109 ] 缓冲区合并语法Node 缓冲区合并的语法如下所示：1Buffer.concat(list[, totalLength]) 参数 list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值返回一个多个成员合并的新 Buffer 对象。 实例1234var buffer1 = new Buffer('前端菜鸟 ');var buffer2 = new Buffer('www.runoob.com');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(\"buffer3 内容: \" + buffer3.toString()); 输出结果为1buffer3 内容: 前端菜鸟 缓冲区比较语法Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：1buf.compare(otherBuffer); 参数otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象 返回值返回一个数字，表示 buf 在 otherBuffer 之前(result0)或相同(result=0)。 实例12345678910var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");&#125;else if(result == 0)&#123; console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");&#125;else &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");&#125; 输出结果：1ABC在ABCD之前 拷贝缓冲区语法Node 缓冲区拷贝语法如下所示：1buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) 参数 targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值没有返回值。 实例12345var buffer1 = new Buffer('ABC');// 拷贝一个缓冲区var buffer2 = new Buffer(3);buffer1.copy(buffer2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ABC 缓冲区裁剪语法Node 缓冲区裁剪语法如下所示：1buf.slice([start[, end]]) 参数 start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例1234var buffer1 = new Buffer('runoob');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ru 缓冲区长度语法Node 缓冲区长度计算语法如下所示：1buf.length; 返回值返回 Buffer 对象所占据的内存长度。 实例123var buffer = new Buffer('www.baidu.com');// 缓冲区长度console.log(\"buffer length: \" + buffer.length); 输出结果为：1buffer length: 13 方法参考手册new Buffer(size)分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 new Buffer(buffer)拷贝参数 buffer 的数据到 Buffer 实例。 new Buffer(str[, encoding])分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 buf.length返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js EventEmitter","date":"2017-07-20T06:50:44.000Z","path":"2017/07/20/node05/","text":"Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。下面我们用一个简单的例子说明 EventEmitter 的用法：123456789//event.js 文件var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function() &#123; console.log('some_event 事件触发');&#125;);setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 执行结果如下：运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。12$ node event.jssome_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。让我们以下面的例子解释这个过程：12345678910//event.js 文件var events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2);&#125;);emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2);&#125;);emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 执行以上代码，运行的结果如下： 123$ node event.jslistener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部。on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法listenerCount(emitter, event)返回指定事件的监听器数量。 事件newListener(event, listener)event - 字符串，事件名称listener - 处理事件函数该事件在添加新监听器时被触发。 removeListener(event, listener)event - 字符串，事件名称listener - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。创建 main.js 文件，代码如下：1234567891011121314151617181920212223242526var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");// 处理 connection 事件eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log(\"listener1 不再受监听。\");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");console.log(\"程序执行完毕。\"); 运行结果12345678$ node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕。 error事件error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：123var events = require('events');var emitter = new events.EventEmitter();emitter.emit('error'); 运行时会显示以下错误：123456789101112node.js:201throw e; // process.nextTick error, or 'error' event on first tick^Error: Uncaught, unspecified 'error' event.at EventEmitter.emit (events.js:50:15)at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。为什么要这样做呢？原因有两点：首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 事件循环","date":"2017-07-20T06:50:31.000Z","path":"2017/07/20/node04/","text":"Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 实例12345678910111213141516171819// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\"); 接下来让我们执行以上代码：1234$ node main.js连接成功。数据接收成功。程序执行完毕。 Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：1node.js 事件循环 创建 main.js 文件，代码如下：123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：12程序执行完毕node.js 事件循环 接下来我们删除 input.txt 文件，执行结果如下所示：12程序执行完毕Error: ENOENT, open 'input.txt' 因为文件 input.txt 不存在，所以输出了错误信息。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 回调函数","date":"2017-07-20T06:50:16.000Z","path":"2017/07/20/node03/","text":"Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是阻塞模式 创建 main.js 文件, 代码如下： 1234var fs = require(\"fs\");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(\"程序执行结束!\"); 结果：123$ node main.jshello，这是阻塞模式程序执行结束! 非阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是非阻塞模式 创建 main.js 文件, 代码如下： 123456var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"程序执行结束!\"); 结果：123$ node main.js程序执行结束!hello，这是非阻塞模式 总结 我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞调用在文件读取完后才执行完程序。非阻塞调用我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js REPL(交互式解释器)","date":"2017-07-20T06:31:25.000Z","path":"2017/07/20/node02/","text":"Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。 我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 简单的表达式运算123456789101112$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt; 使用变量你可以将数据存储在变量中，并在你需要的时候使用它。变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。使用 var 关键字的变量可以使用 console.log() 来输出变量。 12345678910111213$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(\"Hello World\")Hello Worldundefined&gt; console.log(\"www.baidu.com\")www.baidu.comundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314$ node&gt; var x = 0undefined&gt; do &#123;... x++;... console.log(\"x: \" + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线(_)变量你可以使用下划线(_)获取表达式的运算结果：12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 停止 REPL前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 创建第一个应用","date":"2017-07-20T06:08:00.000Z","path":"2017/07/20/node01/","text":"使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。 node.js应用由哪几部分组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 实例123456789101112//引入 required 模块var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 分析node.js的HTTP服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]}]