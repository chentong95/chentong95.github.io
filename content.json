[{"title":"node10","date":"2017-07-20T06:52:43.000Z","path":"2017/07/20/node10/","text":"","tags":[]},{"title":"node09","date":"2017-07-20T06:52:28.000Z","path":"2017/07/20/node09/","text":"","tags":[]},{"title":"node08","date":"2017-07-20T06:52:13.000Z","path":"2017/07/20/node08/","text":"","tags":[]},{"title":"Node.js Stream(流)","date":"2017-07-20T06:52:02.000Z","path":"2017/07/20/node07/","text":"","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js Buffer(缓冲区)","date":"2017-07-20T06:50:57.000Z","path":"2017/07/20/node06/","text":"JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建Buffer类Node Buffer 类可以通过多种方式来创建。 方法 1创建长度为 10 字节的 Buffer 实例：1var buf = new Buffer(10); 方法 2通过给定的数组创建 Buffer 实例：1var buf = new Buffer([10, 20, 30, 40, 50]); 方法 3通过一个字符串来创建 Buffer 实例：1var buf = new Buffer(\"www.baidu.com\", \"utf-8\"); utf-8 是默认的编码方式，此外它同样支持以下编码：”ascii”, “utf8”, “utf16le”, “ucs2”, “base64” 和 “hex”。 写入缓冲区语法写入 Node 缓冲区的语法如下所示：1buf.write(string[, offset[, length]][, encoding]) 参数 string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例123buf = new Buffer(256);len = buf.write(\"www.runoob.com\");console.log(\"写入字节数 : \"+ len); 输出结果为：12$node main.js写入字节数 : 13 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示：1buf.toString([encoding[, start[, end]]]) 参数 encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例12345678buf = new Buffer(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 输出结果为：12345$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde 将 Buffer 转换为 JSON 对象语法将 Node Buffer 转换为 JSON 对象的函数语法格式如下：1buf.toJSON() 返回值返回 JSON 对象。 实例123var buf = new Buffer('www.baidu.com');var json = buf.toJSON(buf);console.log(json); 输出结果为：1[ 119, 119, 119, 46, 98, 97, 105, 100, 117, 46, 99, 111, 109 ] 缓冲区合并语法Node 缓冲区合并的语法如下所示：1Buffer.concat(list[, totalLength]) 参数 list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值返回一个多个成员合并的新 Buffer 对象。 实例1234var buffer1 = new Buffer('前端菜鸟 ');var buffer2 = new Buffer('www.runoob.com');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(\"buffer3 内容: \" + buffer3.toString()); 输出结果为1buffer3 内容: 前端菜鸟 缓冲区比较语法Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：1buf.compare(otherBuffer); 参数otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象 返回值返回一个数字，表示 buf 在 otherBuffer 之前(result0)或相同(result=0)。 实例12345678910var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");&#125;else if(result == 0)&#123; console.log(buffer1 + \" 与 \" + buffer2 + \"相同\");&#125;else &#123; console.log(buffer1 + \" 在 \" + buffer2 + \"之后\");&#125; 输出结果：1ABC在ABCD之前 拷贝缓冲区语法Node 缓冲区拷贝语法如下所示：1buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) 参数 targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值没有返回值。 实例12345var buffer1 = new Buffer('ABC');// 拷贝一个缓冲区var buffer2 = new Buffer(3);buffer1.copy(buffer2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ABC 缓冲区裁剪语法Node 缓冲区裁剪语法如下所示：1buf.slice([start[, end]]) 参数 start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例1234var buffer1 = new Buffer('runoob');// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log(\"buffer2 content: \" + buffer2.toString()); 输出结果为1buffer2 content: ru 缓冲区长度语法Node 缓冲区长度计算语法如下所示：1buf.length; 返回值返回 Buffer 对象所占据的内存长度。 实例123var buffer = new Buffer('www.baidu.com');// 缓冲区长度console.log(\"buffer length: \" + buffer.length); 输出结果为：1buffer length: 13 方法参考手册new Buffer(size)分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 new Buffer(buffer)拷贝参数 buffer 的数据到 Buffer 实例。 new Buffer(str[, encoding])分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 buf.length返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js EventEmitter","date":"2017-07-20T06:50:44.000Z","path":"2017/07/20/node05/","text":"Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。下面我们用一个简单的例子说明 EventEmitter 的用法：123456789//event.js 文件var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function() &#123; console.log('some_event 事件触发');&#125;);setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 执行结果如下：运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。12$ node event.jssome_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。让我们以下面的例子解释这个过程：12345678910//event.js 文件var events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2);&#125;);emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2);&#125;);emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 执行以上代码，运行的结果如下： 123$ node event.jslistener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部。on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法listenerCount(emitter, event)返回指定事件的监听器数量。 事件newListener(event, listener)event - 字符串，事件名称listener - 处理事件函数该事件在添加新监听器时被触发。 removeListener(event, listener)event - 字符串，事件名称listener - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。创建 main.js 文件，代码如下：1234567891011121314151617181920212223242526var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");// 处理 connection 事件eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log(\"listener1 不再受监听。\");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");console.log(\"程序执行完毕。\"); 运行结果12345678$ node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕。 error事件error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：123var events = require('events');var emitter = new events.EventEmitter();emitter.emit('error'); 运行时会显示以下错误：123456789101112node.js:201throw e; // process.nextTick error, or 'error' event on first tick^Error: Uncaught, unspecified 'error' event.at EventEmitter.emit (events.js:50:15)at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。为什么要这样做呢？原因有两点：首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 事件循环","date":"2017-07-20T06:50:31.000Z","path":"2017/07/20/node04/","text":"Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 实例12345678910111213141516171819// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\"); 接下来让我们执行以上代码：1234$ node main.js连接成功。数据接收成功。程序执行完毕。 Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：1node.js 事件循环 创建 main.js 文件，代码如下：123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：12程序执行完毕node.js 事件循环 接下来我们删除 input.txt 文件，执行结果如下所示：12程序执行完毕Error: ENOENT, open 'input.txt' 因为文件 input.txt 不存在，所以输出了错误信息。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 回调函数","date":"2017-07-20T06:50:16.000Z","path":"2017/07/20/node03/","text":"Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是阻塞模式 创建 main.js 文件, 代码如下： 1234var fs = require(\"fs\");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(\"程序执行结束!\"); 结果：123$ node main.jshello，这是阻塞模式程序执行结束! 非阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是非阻塞模式 创建 main.js 文件, 代码如下： 123456var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"程序执行结束!\"); 结果：123$ node main.js程序执行结束!hello，这是非阻塞模式 总结 我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞调用在文件读取完后才执行完程序。非阻塞调用我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js REPL(交互式解释器)","date":"2017-07-20T06:31:25.000Z","path":"2017/07/20/node02/","text":"Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。 我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 简单的表达式运算123456789101112$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt; 使用变量你可以将数据存储在变量中，并在你需要的时候使用它。变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。使用 var 关键字的变量可以使用 console.log() 来输出变量。 12345678910111213$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(\"Hello World\")Hello Worldundefined&gt; console.log(\"www.baidu.com\")www.baidu.comundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314$ node&gt; var x = 0undefined&gt; do &#123;... x++;... console.log(\"x: \" + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线(_)变量你可以使用下划线(_)获取表达式的运算结果：12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 停止 REPL前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 创建第一个应用","date":"2017-07-20T06:08:00.000Z","path":"2017/07/20/node01/","text":"使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。 node.js应用由哪几部分组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 实例123456789101112//引入 required 模块var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 分析node.js的HTTP服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]}]