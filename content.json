[{"title":"node10","date":"2017-07-20T06:52:43.000Z","path":"2017/07/20/node10/","text":"","tags":[]},{"title":"node09","date":"2017-07-20T06:52:28.000Z","path":"2017/07/20/node09/","text":"","tags":[]},{"title":"node08","date":"2017-07-20T06:52:13.000Z","path":"2017/07/20/node08/","text":"","tags":[]},{"title":"node07","date":"2017-07-20T06:52:02.000Z","path":"2017/07/20/node07/","text":"","tags":[]},{"title":"node06","date":"2017-07-20T06:50:57.000Z","path":"2017/07/20/node06/","text":"","tags":[]},{"title":"Node.js EventEmitter","date":"2017-07-20T06:50:44.000Z","path":"2017/07/20/node05/","text":"Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(“events”);来访问该模块。1234// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。下面我们用一个简单的例子说明 EventEmitter 的用法：123456789//event.js 文件var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function() &#123; console.log('some_event 事件触发');&#125;);setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 执行结果如下：运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。12$ node event.jssome_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。让我们以下面的例子解释这个过程：12345678910//event.js 文件var events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2);&#125;);emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2);&#125;);emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 执行以上代码，运行的结果如下： 123$ node event.jslistener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部。on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。123server.on('connection', function (stream) &#123; console.log('someone connected!');&#125;); once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回指定事件的监听器数组。 emit(event, [arg1], [arg2], […])按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法listenerCount(emitter, event)返回指定事件的监听器数量。 事件newListener(event, listener)event - 字符串，事件名称listener - 处理事件函数该事件在添加新监听器时被触发。 removeListener(event, listener)event - 字符串，事件名称listener - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引 实例以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。创建 main.js 文件，代码如下：1234567891011121314151617181920212223242526var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定 connection 事件，处理函数为 listener1eventEmitter.addListener('connection', listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");// 处理 connection 事件eventEmitter.emit('connection');// 移除监绑定的 listener1 函数eventEmitter.removeListener('connection', listener1);console.log(\"listener1 不再受监听。\");// 触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");console.log(\"程序执行完毕。\"); 运行结果12345678$ node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕。 error事件error 事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：123var events = require('events');var emitter = new events.EventEmitter();emitter.emit('error'); 运行时会显示以下错误：123456789101112node.js:201throw e; // process.nextTick error, or 'error' event on first tick^Error: Uncaught, unspecified 'error' event.at EventEmitter.emit (events.js:50:15)at Object.&lt;anonymous&gt; (/home/byvoid/error.js:5:9)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40) 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。为什么要这样做呢？原因有两点：首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 事件循环","date":"2017-07-20T06:50:31.000Z","path":"2017/07/20/node04/","text":"Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。 Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序 Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。 实例12345678910111213141516171819// 引入 events 模块var events = require('events');// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() &#123; console.log('连接成功。'); // 触发 data_received 事件 eventEmitter.emit('data_received');&#125;// 绑定 connection 事件处理程序eventEmitter.on('connection', connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);// 触发 connection 事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\"); 接下来让我们执行以上代码：1234$ node main.js连接成功。数据接收成功。程序执行完毕。 Node 应用程序是如何工作的？在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：1node.js 事件循环 创建 main.js 文件，代码如下：123456789var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：12程序执行完毕node.js 事件循环 接下来我们删除 input.txt 文件，执行结果如下所示：12程序执行完毕Error: ENOENT, open 'input.txt' 因为文件 input.txt 不存在，所以输出了错误信息。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 回调函数","date":"2017-07-20T06:50:16.000Z","path":"2017/07/20/node03/","text":"Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是阻塞模式 创建 main.js 文件, 代码如下： 1234var fs = require(\"fs\");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(\"程序执行结束!\"); 结果：123$ node main.jshello，这是阻塞模式程序执行结束! 非阻塞代码实例创建一个文件 input.txt ，内容如下：1hello，这是非阻塞模式 创建 main.js 文件, 代码如下： 123456var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"程序执行结束!\"); 结果：123$ node main.js程序执行结束!hello，这是非阻塞模式 总结 我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 阻塞调用在文件读取完后才执行完程序。非阻塞调用我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js REPL(交互式解释器)","date":"2017-07-20T06:31:25.000Z","path":"2017/07/20/node02/","text":"Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。 我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 简单的表达式运算123456789101112$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt; 使用变量你可以将数据存储在变量中，并在你需要的时候使用它。变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。使用 var 关键字的变量可以使用 console.log() 来输出变量。 12345678910111213$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(\"Hello World\")Hello Worldundefined&gt; console.log(\"www.baidu.com\")www.baidu.comundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：1234567891011121314$ node&gt; var x = 0undefined&gt; do &#123;... x++;... console.log(\"x: \" + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt; … 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线(_)变量你可以使用下划线(_)获取表达式的运算结果：12345678910111213$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt; REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 停止 REPL前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Node.js 创建第一个应用","date":"2017-07-20T06:08:00.000Z","path":"2017/07/20/node01/","text":"使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。 node.js应用由哪几部分组成 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 实例123456789101112//引入 required 模块var http = require('http');http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 分析node.js的HTTP服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。 接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。","tags":[{"name":"node","slug":"node","permalink":"https://github.com/chentong95/chentong95.github.io.git/tags/node/"}]},{"title":"Hello World","date":"2017-07-20T02:15:38.484Z","path":"2017/07/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]